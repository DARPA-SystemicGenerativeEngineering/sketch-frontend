
class VarDB{ // One copy of this object per thread.
    int* localDB; //this one is local
    int* globalDB; //this buffer is shared among all threads
    
    
    int setValue(int varid, int val){
        localDB[varid] = val;
        if(globalDB[varid]==UNSET){
            globalDB[varid] = val;
            return NOCONFLICT;
        }
        if(value(val)==value(globalDB[varid])){            
            return NOCONFLICT;
        }
        return globalDB[varid]; // there is a conflict.
    }    
}

class VarDB{
    int getValue(int varid){
        if(localDB[varid] == UNSET){
            return globalDB[varid];
        }else{
            return localDB[varid];
        }
    }    
}




int N = 6;
int SR = (1 + N + 3);
int STEPS = 8;
int NP = 15;

int[N] CAS(int[N] input, int a, int b) {
    int[N] output = input;
    if ((a <= b) && (output[a] > output[b])) {
        output[b] = input[a];
        output[a] = input[b];
    }
    return output;
}

int[N] CASR(int[N] input, int a, int b) {
    int[N] output = input;
    if ((a <= b) && (output[a] < output[b])) {
        output[b] = input[a];
        output[a] = input[b];
    }
    return output;
}

bit[N][N] b_CAS(bit[N][N] input, int a, int b) {
    bit[N][N] output = input;
    output[a] = output[a] | output[b];
    output[b] = output[a] | output[b];
    return output;
}

// each call should have a fixed length parameter
generator int[N] sortAtom(int[N] input, int length, int index, bit reverse, int[3] stars) {
    int[N] output = input;
    for (int x = index; x < index + (length / 2); x++) {
        int expr = (stars[0] != 0 ? x + stars[1] : x - stars[2]);
        if (reverse) {
            output = CAS(output, x, expr);
        } else {
            output = CASR(output, x, expr);
        }
    }
    return output;
}

// each call should have a fixed length parameter
generator bit[N][N] b_sortAtom(bit[N][N] input, int length, int index, int[3] stars) {
    bit[N][N] output = input;
    for (int x = index; x < index + (length / 2); x++) {
        int expr = (stars[0] != 0 ? x + stars[1] : x - stars[2]);
        output = b_CAS(output, x, expr);
    }
    return output;
}

generator int[N] sortEntireWithLength(int[N] input, int length, int[SR-1] stars) {
    int[N] output = input;
    assert (length > 0 && length <= N);
    int offset = 0;
    int idx = 0;
    bit[N] harr = {stars[0] != 0, stars[1] != 0, stars[2] != 0, stars[3] != 0};
    while (offset + length <= N) {
        output = sortAtom(output, length, offset, harr[idx], stars[4::3]);
        offset += length;
        idx += 1;
    }
    return output;
}

generator bit[N][N] b_sortEntireWithLength(bit[N][N] input, int length, int[SR-1] stars) {
    bit[N][N] output = input;
    int offset = 0;
    while (offset + length <= N) {
        output = b_sortAtom(output, length, offset, stars[4::3]);
        offset += length;
    }
    return output;
}

harness int[N] main(int[N] input) {
    int[N] output = input;

    int[STEPS * SR] holes = ??;
    int[NP] points = ??;
    int[STEPS * SR] point_belongs_to = ??;
    for (int a = 0; a < STEPS * SR; a++) {
        assert point_belongs_to[a] < NP;
        assert holes[a] == (points[point_belongs_to[a]]);
    }

    output = sortEntireWithLength(output, holes[SR * 0], holes[SR * 0 + 1::(SR-1)]);
    output = sortEntireWithLength(output, holes[SR * 1], holes[SR * 1 + 1::(SR-1)]);
    output = sortEntireWithLength(output, holes[SR * 2], holes[SR * 2 + 1::(SR-1)]);
    output = sortEntireWithLength(output, holes[SR * 3], holes[SR * 3 + 1::(SR-1)]);
    output = sortEntireWithLength(output, holes[SR * 4], holes[SR * 4 + 1::(SR-1)]);
    output = sortEntireWithLength(output, holes[SR * 5], holes[SR * 5 + 1::(SR-1)]);
    output = sortEntireWithLength(output, holes[SR * 6], holes[SR * 6 + 1::(SR-1)]);
    output = sortEntireWithLength(output, holes[SR * 7], holes[SR * 7 + 1::(SR-1)]);

    bit[N][N] entropyValues = {
        { 1, 0, 0, 0, 0, 0 },
        { 0, 1, 0, 0, 0, 0 },
        { 0, 0, 1, 0, 0, 0 },
        { 0, 0, 0, 1, 0, 0 },
        { 0, 0, 0, 0, 1, 0 },
        { 0, 0, 0, 0, 0, 1 } };

    bit[N][N] entropyOut = b_sortEntireWithLength(entropyValues, holes[SR * 0], holes[SR * 0 + 1::(SR-1)]);
        entropyOut = b_sortEntireWithLength(entropyOut, holes[SR * 1], holes[SR * 1 + 1::(SR-1)]);
        entropyOut = b_sortEntireWithLength(entropyOut, holes[SR * 2], holes[SR * 2 + 1::(SR-1)]);
        entropyOut = b_sortEntireWithLength(entropyOut, holes[SR * 3], holes[SR * 3 + 1::(SR-1)]);
        entropyOut = b_sortEntireWithLength(entropyOut, holes[SR * 4], holes[SR * 4 + 1::(SR-1)]);
        entropyOut = b_sortEntireWithLength(entropyOut, holes[SR * 5], holes[SR * 5 + 1::(SR-1)]);
        entropyOut = b_sortEntireWithLength(entropyOut, holes[SR * 6], holes[SR * 6 + 1::(SR-1)]);
        entropyOut = b_sortEntireWithLength(entropyOut, holes[SR * 7], holes[SR * 7 + 1::(SR-1)]);

    // entropy check
    for (int a = 0; a < N; a++) {
        assert entropyOut[a] == { 1, 1, 1, 1, 1, 1 };
    }

    // is sorted
    for (int a = 0; a < N - 1; a++) {
        assert output[a] <= output[a + 1];
    }
    return output;
}
