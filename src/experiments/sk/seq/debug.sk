
pragma options "--bnd-unroll-amnt 16 --bnd-inbits 2";

// return A[i] where A is of length N 
int get (int i, int N, int [N] A)
{
  assert i<N;
  return A[i];
}

// append v to A, where A is of length N 
int [N+1] appendInt (int v, int N, int [N] A)
{
  int[N+1] out;
  out[0::N] = A;
  out[N] = v;
  return out;
}

// top T entries of A of length N 
int [T] top (int T, int N, int [N] A)
{
  if (T <= N)
    return A[0::T];
  else
    return 0;
}

// lists l1 with length l1Len and l2 with length l2Len are equal 
bit intListEquals (int l1Len, int [l1Len] l1, int l2Len, int [l2Len] l2)
{
  return l1 == l2 && l1Len == l2Len;
}

struct Tuple
{
  int first;
  int second;
}

bit tupleListEquals (int l1Len, Tuple[l1Len] l1, int l2Len, Tuple[l2Len] l2)
{
  if (l1Len != l2Len)
    return 0;

  for (int i = 0; i < l1Len; ++i)
  {
    if (l1[i].first != l2[i].first || l1[i].second != l2[i].second)
      return 0;
  }

  return 1 && l1Len == l2Len;
}


// append tuple to a tuple list
Tuple [len+1] appendTuple (Tuple t, int len, Tuple [len] l)
{
  Tuple [len+1] out;
  /*
  out[0::len] = l;
  out[len] = t;
  */

  for (int i = 0; i < len; ++i)
  {
    out[i] = new Tuple();
    out[i].first = l[i].first;
    out[i].second = l[i].second;
  }

  
  out[len] = new Tuple();
  out[len].second = t.second;
  out[len].first = t.first;
  
  return out;
}

// append l2 to the end of l1
Tuple [len1 + len2] appendTupleList (int len1, Tuple [len1] l1, 
                                     int len2, Tuple [len2] l2)
{
  
  Tuple [len1 + len2] out;
  out[0::len1] = l1;
  out[len1::len2] = l2;
  return out;
  
}


Tuple [len1 * len2] product (int len1, int [len1] l1, int len2, int [len2] l2)
{
  Tuple [len1 * len2] out;

  for (int i = 0; i < len1; ++i)
  {
    for (int j = 0; j < len2; ++j)
    {
      int e1 = l1[i];
      int e2 = l2[j];

      Tuple t = new Tuple();
      t.first = e1;
      t.second = e2;

      out[i * len2 + j] = t;
    }
  }

  return out;
}


Tuple [len2] leftProduct (int v, int len2, int [len2] l2)
{
  //if (len2 <= 0)
  //  return null;

  Tuple [len2] out;

  for (int j = 0; j < len2; ++j)
  {
    Tuple t = new Tuple();
    t.first = v;
    t.second = l2[j];

    out[j] = t;
  }

  return out;
}

bit innerInvariant (int lenRet, Tuple [lenRet] ret, 
                    int len1, int [len1] l1,
                    int len2, int [len2] l2,
                    int i, int j, int t1)
{
  Tuple [i*len2] previous = product(i, top(i, len1, l1), len2, l2);
  Tuple [j] current = leftProduct(t1, j, top(j, len2, l2));
  Tuple [i*len2+j] retEquals = appendTupleList(i*len2, previous, j, current);

  return tupleListEquals(lenRet, ret, i*len2+j, retEquals) &&
         i+1 <= len1 && t1 == get(i, len1, l1) && j <= len2;
}

bit outerInvariant (int lenRet, Tuple[lenRet] ret,
                    int len1, int [len1] l1,
                    int len2, int [len2] l2,
                    int i)
{
  Tuple [i*len2] p = product(i, top(i, len1, l1), len2, l2);
  return tupleListEquals(lenRet, ret, i*len2, p) &&
         i <= len1;
}
           
harness void sketch (int lenRet, int [lenRet] r1, int [lenRet] r2,
                     int len1, int [len1] l1,
                     int len2, int [len2] l2, 
                     int j, int i, int t1)
{
  assert len2 >= 0;
  assert len1 >= 0;
  assert lenRet >= 0;

  Tuple [lenRet] ret;
  for (int m = 0; m < lenRet; ++m)
  {
    ret[m] = new Tuple();
    ret[m].first = r1[m];
    ret[m].second = r2[m];
  }

  
  if (innerInvariant(lenRet, ret, len1, l1, len2, l2, i, j, t1) && 
      j < len2)
  {
    
    Tuple newTuple = new Tuple();
    newTuple.first = t1;
    newTuple.second = l2[j];
    
    Tuple [lenRet+1] newRet = appendTuple(newTuple, lenRet, ret);
    assert innerInvariant(lenRet+1, newRet, len1, l1, len2, l2, i, j+1, t1);
  }
  
  if (innerInvariant(lenRet, ret, len1, l1, len2, l2, i, j, t1) &&
      !(j < len2))
  {
    assert outerInvariant(lenRet, ret, len1, l1, len2, l2, i+1);
  }
 
  if (outerInvariant(lenRet, ret, len1, l1, len2, l2, i) && i < len1)
  {
    assert innerInvariant(lenRet, ret, len1, l1, len2, l2, i, 0, get(i, len1, l1));
  }

  

    
}



void qun (int lenRet, int [lenRet] r1, int [lenRet] r2,
                     //int len1, int [len1] l1,
                     int len2, int [len2] l2, 
                     int t1, int j, int i)
{
  int[j] topL2 = top(j, len2, l2); 
  if (tupleListEquals(lenRet, ret, j, leftProduct(t1, j, top(j, len2, l2)))
      && j < len2)
  {
    
    Tuple newTuple = new Tuple();
    newTuple.first = t1;
    newTuple.second = l2[j];

    Tuple[lenRet+1] newRet = appendTuple(newTuple, lenRet, ret);

    for (int m = 0; m < lenRet; ++m)
    {
      assert newRet[m].first == ret[m].first;
      assert newRet[m].second == ret[m].second;
    }
    
  }
  
}
  
  


