
sse_transpose:     file format elf32-i386

Disassembly of section .init:

0804841c <_init>:
 804841c:	55                   	push   %ebp
 804841d:	89 e5                	mov    %esp,%ebp
 804841f:	53                   	push   %ebx
 8048420:	83 ec 04             	sub    $0x4,%esp
 8048423:	e8 00 00 00 00       	call   8048428 <_init+0xc>
 8048428:	5b                   	pop    %ebx
 8048429:	81 c3 cc 2b 00 00    	add    $0x2bcc,%ebx
 804842f:	8b 93 fc ff ff ff    	mov    -0x4(%ebx),%edx
 8048435:	85 d2                	test   %edx,%edx
 8048437:	74 05                	je     804843e <_init+0x22>
 8048439:	e8 1e 00 00 00       	call   804845c <__gmon_start__@plt>
 804843e:	e8 ed 00 00 00       	call   8048530 <frame_dummy>
 8048443:	e8 d8 09 00 00       	call   8048e20 <__do_global_ctors_aux>
 8048448:	58                   	pop    %eax
 8048449:	5b                   	pop    %ebx
 804844a:	c9                   	leave  
 804844b:	c3                   	ret    
Disassembly of section .plt:

0804844c <__gmon_start__@plt-0x10>:
 804844c:	ff 35 f8 af 04 08    	pushl  0x804aff8
 8048452:	ff 25 fc af 04 08    	jmp    *0x804affc
 8048458:	00 00                	add    %al,(%eax)
	...

0804845c <__gmon_start__@plt>:
 804845c:	ff 25 00 b0 04 08    	jmp    *0x804b000
 8048462:	68 00 00 00 00       	push   $0x0
 8048467:	e9 e0 ff ff ff       	jmp    804844c <_init+0x30>

0804846c <__libc_start_main@plt>:
 804846c:	ff 25 04 b0 04 08    	jmp    *0x804b004
 8048472:	68 08 00 00 00       	push   $0x8
 8048477:	e9 d0 ff ff ff       	jmp    804844c <_init+0x30>

0804847c <__assert_fail@plt>:
 804847c:	ff 25 08 b0 04 08    	jmp    *0x804b008
 8048482:	68 10 00 00 00       	push   $0x10
 8048487:	e9 c0 ff ff ff       	jmp    804844c <_init+0x30>

0804848c <gettimeofday@plt>:
 804848c:	ff 25 0c b0 04 08    	jmp    *0x804b00c
 8048492:	68 18 00 00 00       	push   $0x18
 8048497:	e9 b0 ff ff ff       	jmp    804844c <_init+0x30>

0804849c <printf@plt>:
 804849c:	ff 25 10 b0 04 08    	jmp    *0x804b010
 80484a2:	68 20 00 00 00       	push   $0x20
 80484a7:	e9 a0 ff ff ff       	jmp    804844c <_init+0x30>

080484ac <puts@plt>:
 80484ac:	ff 25 14 b0 04 08    	jmp    *0x804b014
 80484b2:	68 28 00 00 00       	push   $0x28
 80484b7:	e9 90 ff ff ff       	jmp    804844c <_init+0x30>

080484bc <__gxx_personality_v0@plt>:
 80484bc:	ff 25 18 b0 04 08    	jmp    *0x804b018
 80484c2:	68 30 00 00 00       	push   $0x30
 80484c7:	e9 80 ff ff ff       	jmp    804844c <_init+0x30>
Disassembly of section .text:

080484d0 <_start>:
 80484d0:	31 ed                	xor    %ebp,%ebp
 80484d2:	5e                   	pop    %esi
 80484d3:	89 e1                	mov    %esp,%ecx
 80484d5:	83 e4 f0             	and    $0xfffffff0,%esp
 80484d8:	50                   	push   %eax
 80484d9:	54                   	push   %esp
 80484da:	52                   	push   %edx
 80484db:	68 b0 8d 04 08       	push   $0x8048db0
 80484e0:	68 c0 8d 04 08       	push   $0x8048dc0
 80484e5:	51                   	push   %ecx
 80484e6:	56                   	push   %esi
 80484e7:	68 70 8a 04 08       	push   $0x8048a70
 80484ec:	e8 7b ff ff ff       	call   804846c <__libc_start_main@plt>
 80484f1:	f4                   	hlt    
 80484f2:	90                   	nop    
 80484f3:	90                   	nop    
 80484f4:	90                   	nop    
 80484f5:	90                   	nop    
 80484f6:	90                   	nop    
 80484f7:	90                   	nop    
 80484f8:	90                   	nop    
 80484f9:	90                   	nop    
 80484fa:	90                   	nop    
 80484fb:	90                   	nop    
 80484fc:	90                   	nop    
 80484fd:	90                   	nop    
 80484fe:	90                   	nop    
 80484ff:	90                   	nop    

08048500 <__do_global_dtors_aux>:
 8048500:	55                   	push   %ebp
 8048501:	89 e5                	mov    %esp,%ebp
 8048503:	83 ec 08             	sub    $0x8,%esp
 8048506:	80 3d 30 b0 04 08 00 	cmpb   $0x0,0x804b030
 804850d:	74 0c                	je     804851b <__do_global_dtors_aux+0x1b>
 804850f:	eb 1c                	jmp    804852d <__do_global_dtors_aux+0x2d>
 8048511:	83 c0 04             	add    $0x4,%eax
 8048514:	a3 24 b0 04 08       	mov    %eax,0x804b024
 8048519:	ff d2                	call   *%edx
 804851b:	a1 24 b0 04 08       	mov    0x804b024,%eax
 8048520:	8b 10                	mov    (%eax),%edx
 8048522:	85 d2                	test   %edx,%edx
 8048524:	75 eb                	jne    8048511 <__do_global_dtors_aux+0x11>
 8048526:	c6 05 30 b0 04 08 01 	movb   $0x1,0x804b030
 804852d:	c9                   	leave  
 804852e:	c3                   	ret    
 804852f:	90                   	nop    

08048530 <frame_dummy>:
 8048530:	55                   	push   %ebp
 8048531:	89 e5                	mov    %esp,%ebp
 8048533:	83 ec 08             	sub    $0x8,%esp
 8048536:	a1 04 af 04 08       	mov    0x804af04,%eax
 804853b:	85 c0                	test   %eax,%eax
 804853d:	74 12                	je     8048551 <frame_dummy+0x21>
 804853f:	b8 00 00 00 00       	mov    $0x0,%eax
 8048544:	85 c0                	test   %eax,%eax
 8048546:	74 09                	je     8048551 <frame_dummy+0x21>
 8048548:	c7 04 24 04 af 04 08 	movl   $0x804af04,(%esp)
 804854f:	ff d0                	call   *%eax
 8048551:	c9                   	leave  
 8048552:	c3                   	ret    
 8048553:	90                   	nop    
 8048554:	90                   	nop    
 8048555:	90                   	nop    
 8048556:	90                   	nop    
 8048557:	90                   	nop    
 8048558:	90                   	nop    
 8048559:	90                   	nop    
 804855a:	90                   	nop    
 804855b:	90                   	nop    
 804855c:	90                   	nop    
 804855d:	90                   	nop    
 804855e:	90                   	nop    
 804855f:	90                   	nop    

08048560 <_Z12print_matrixPf>:
    in[3]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(3, 0, 3, 0));
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

 8048560:	55                   	push   %ebp
 8048561:	89 e5                	mov    %esp,%ebp
 8048563:	56                   	push   %esi
 8048564:	be 01 00 00 00       	mov    $0x1,%esi
 8048569:	53                   	push   %ebx
 804856a:	8d 46 ff             	lea    -0x1(%esi),%eax
 804856d:	83 ec 30             	sub    $0x30,%esp
 8048570:	8b 5d 08             	mov    0x8(%ebp),%ebx
void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048573:	83 f8 03             	cmp    $0x3,%eax
 8048576:	74 51                	je     80485c9 <_Z12print_matrixPf+0x69>
 8048578:	d9 43 0c             	flds   0xc(%ebx)
 804857b:	85 c0                	test   %eax,%eax
 804857d:	d9 43 08             	flds   0x8(%ebx)
 8048580:	d9 43 04             	flds   0x4(%ebx)
 8048583:	d9 03                	flds   (%ebx)
 8048585:	0f 85 86 00 00 00    	jne    8048611 <_Z12print_matrixPf+0xb1>
 804858b:	d9 cb                	fxch   %st(3)
 804858d:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048591:	d9 c9                	fxch   %st(1)
 8048593:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048597:	dd 5c 24 10          	fstpl  0x10(%esp)
 804859b:	c7 44 24 28 70 8e 04 	movl   $0x8048e70,0x28(%esp)
 80485a2:	08 
 80485a3:	dd 5c 24 08          	fstpl  0x8(%esp)
 80485a7:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
 80485ae:	00 
 80485af:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 80485b6:	e8 e1 fe ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 80485bb:	83 c6 01             	add    $0x1,%esi
 80485be:	83 c3 10             	add    $0x10,%ebx
    in[3]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(3, 0, 3, 0));
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

 80485c1:	8d 46 ff             	lea    -0x1(%esi),%eax
void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 80485c4:	83 f8 03             	cmp    $0x3,%eax
 80485c7:	75 af                	jne    8048578 <_Z12print_matrixPf+0x18>
 80485c9:	d9 43 0c             	flds   0xc(%ebx)
 80485cc:	b8 72 8e 04 08       	mov    $0x8048e72,%eax
 80485d1:	d9 43 08             	flds   0x8(%ebx)
 80485d4:	d9 43 04             	flds   0x4(%ebx)
 80485d7:	d9 03                	flds   (%ebx)
 80485d9:	d9 cb                	fxch   %st(3)
 80485db:	dd 5c 24 20          	fstpl  0x20(%esp)
 80485df:	d9 c9                	fxch   %st(1)
 80485e1:	dd 5c 24 18          	fstpl  0x18(%esp)
 80485e5:	dd 5c 24 10          	fstpl  0x10(%esp)
 80485e9:	89 44 24 28          	mov    %eax,0x28(%esp)
 80485ed:	dd 5c 24 08          	fstpl  0x8(%esp)
 80485f1:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 80485f8:	00 
 80485f9:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048600:	e8 97 fe ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048605:	83 fe 03             	cmp    $0x3,%esi
 8048608:	7e b1                	jle    80485bb <_Z12print_matrixPf+0x5b>
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
               row == 3 ? " ]" : ",");
    }
 804860a:	83 c4 30             	add    $0x30,%esp
 804860d:	5b                   	pop    %ebx
 804860e:	5e                   	pop    %esi
 804860f:	5d                   	pop    %ebp
 8048610:	c3                   	ret    
 8048611:	d9 cb                	fxch   %st(3)

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048613:	b8 70 8e 04 08       	mov    $0x8048e70,%eax
 8048618:	eb c1                	jmp    80485db <_Z12print_matrixPf+0x7b>
 804861a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

08048620 <_Z7run_ssePf>:
        transpose(matrix, result);
    }
    print_matrix(matrix);
    print_matrix(result);
}

 8048620:	55                   	push   %ebp
 8048621:	89 e5                	mov    %esp,%ebp
 8048623:	57                   	push   %edi
 8048624:	56                   	push   %esi
 8048625:	53                   	push   %ebx
 8048626:	83 ec 3c             	sub    $0x3c,%esp
 8048629:	8b 5d 08             	mov    0x8(%ebp),%ebx
void run_sse(float *matrix) {
    static float result[16] __attribute__ ((aligned(16)));
 804862c:	c7 04 24 75 8e 04 08 	movl   $0x8048e75,(%esp)
 8048633:	e8 74 fe ff ff       	call   80484ac <puts@plt>

/* Load four SPFP values from P.  The address must be 16-byte aligned.  */
static __inline __m128 __attribute__((__always_inline__))
_mm_load_ps (float const *__P)
{
  return (__m128) *(__v4sf *)__P;
 8048638:	31 c0                	xor    %eax,%eax
 804863a:	0f 28 23             	movaps (%ebx),%xmm4
 804863d:	0f 28 4b 10          	movaps 0x10(%ebx),%xmm1
 8048641:	0f 28 43 20          	movaps 0x20(%ebx),%xmm0
 8048645:	0f 28 6b 30          	movaps 0x30(%ebx),%xmm5
 8048649:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
/// note that when casting bit vectors to int's, earlier
/// bits have lower significance.
inline void sse_transpose(__m128 *in) {
// a = ["01000001", "11101011", "00010100", "11101011", "11001100", "00110110", "10011100", "01100110"]
// print "\n".join([repr(tuple([int(e[0]) + 2*int(e[1]) for e in zip(c[::2], c[1::2])])) for c in a])
    __m128 tmp[4];
 8048650:	0f 28 d5             	movaps %xmm5,%xmm2
    __m128 matrix_as_sse[4];
    // in the current implementation, this could just be a memcpy
    for (int a = 0; a < 4; a++) {
        matrix_as_sse[a] = _mm_load_ps(&matrix[4*a]);
    }

 8048653:	83 c0 01             	add    $0x1,%eax
/// bits have lower significance.
inline void sse_transpose(__m128 *in) {
// a = ["01000001", "11101011", "00010100", "11101011", "11001100", "00110110", "10011100", "01100110"]
// print "\n".join([repr(tuple([int(e[0]) + 2*int(e[1]) for e in zip(c[::2], c[1::2])])) for c in a])
    __m128 tmp[4];
    tmp[0]  = SSE_SHUFFLE(in[3], in[2],  SHUFFLE_BITS(2, 0, 0, 2));
 8048656:	0f 28 dd             	movaps %xmm5,%xmm3
/// note that when casting bit vectors to int's, earlier
/// bits have lower significance.
inline void sse_transpose(__m128 *in) {
// a = ["01000001", "11101011", "00010100", "11101011", "11001100", "00110110", "10011100", "01100110"]
// print "\n".join([repr(tuple([int(e[0]) + 2*int(e[1]) for e in zip(c[::2], c[1::2])])) for c in a])
    __m128 tmp[4];
 8048659:	0f c6 d0 82          	shufps $0x82,%xmm0,%xmm2
    tmp[0]  = SSE_SHUFFLE(in[3], in[2],  SHUFFLE_BITS(2, 0, 0, 2));
 804865d:	0f c6 d8 d7          	shufps $0xd7,%xmm0,%xmm3
    __m128 matrix_as_sse[4];
    // in the current implementation, this could just be a memcpy
    for (int a = 0; a < 4; a++) {
        matrix_as_sse[a] = _mm_load_ps(&matrix[4*a]);
    }

 8048661:	3d 01 ca 9a 3b       	cmp    $0x3b9aca01,%eax
inline void sse_transpose(__m128 *in) {
// a = ["01000001", "11101011", "00010100", "11101011", "11001100", "00110110", "10011100", "01100110"]
// print "\n".join([repr(tuple([int(e[0]) + 2*int(e[1]) for e in zip(c[::2], c[1::2])])) for c in a])
    __m128 tmp[4];
    tmp[0]  = SSE_SHUFFLE(in[3], in[2],  SHUFFLE_BITS(2, 0, 0, 2));
    tmp[2]  = SSE_SHUFFLE(in[3], in[2],  SHUFFLE_BITS(3, 1, 1, 3));
 8048666:	0f 28 c4             	movaps %xmm4,%xmm0
 8048669:	0f c6 c1 28          	shufps $0x28,%xmm1,%xmm0
    tmp[1]  = SSE_SHUFFLE(in[0], in[1],  SHUFFLE_BITS(0, 2, 2, 0));
 804866d:	0f c6 cc d7          	shufps $0xd7,%xmm4,%xmm1
    tmp[3]  = SSE_SHUFFLE(in[1], in[0],  SHUFFLE_BITS(3, 1, 1, 3));

    in[3]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(3, 0, 3, 0));
 8048671:	0f 28 e0             	movaps %xmm0,%xmm4
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
 8048674:	0f c6 c2 39          	shufps $0x39,%xmm2,%xmm0
    __m128 tmp[4];
    tmp[0]  = SSE_SHUFFLE(in[3], in[2],  SHUFFLE_BITS(2, 0, 0, 2));
    tmp[2]  = SSE_SHUFFLE(in[3], in[2],  SHUFFLE_BITS(3, 1, 1, 3));
    tmp[1]  = SSE_SHUFFLE(in[0], in[1],  SHUFFLE_BITS(0, 2, 2, 0));
    tmp[3]  = SSE_SHUFFLE(in[1], in[0],  SHUFFLE_BITS(3, 1, 1, 3));

 8048678:	0f 28 e9             	movaps %xmm1,%xmm5
 804867b:	0f c6 eb 33          	shufps $0x33,%xmm3,%xmm5
    in[3]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(3, 0, 3, 0));
 804867f:	0f c6 e2 6c          	shufps $0x6c,%xmm2,%xmm4
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
 8048683:	0f c6 cb 66          	shufps $0x66,%xmm3,%xmm1
    __m128 matrix_as_sse[4];
    // in the current implementation, this could just be a memcpy
    for (int a = 0; a < 4; a++) {
        matrix_as_sse[a] = _mm_load_ps(&matrix[4*a]);
    }

 8048687:	75 c7                	jne    8048650 <_Z7run_ssePf+0x30>
        sse_transpose(matrix_as_sse);
    }

    // convert back to matrix; each __m128 needs to be 16b aligned
    for (int a = 0; a < 4; a++) {
        float *ptr = &result[4*a];
 8048689:	b8 40 b0 04 08       	mov    $0x804b040,%eax
 804868e:	a8 0f                	test   $0xf,%al
 8048690:	0f 85 cf 01 00 00    	jne    8048865 <_Z7run_ssePf+0x245>
 8048696:	b8 50 b0 04 08       	mov    $0x804b050,%eax
 804869b:	a8 0f                	test   $0xf,%al

/* Store four SPFP values.  The address must be 16-byte aligned.  */
static __inline void __attribute__((__always_inline__))
_mm_store_ps (float *__P, __m128 __A)
{
  *(__v4sf *)__P = (__v4sf)__A;
 804869d:	0f 29 25 40 b0 04 08 	movaps %xmm4,0x804b040
 80486a4:	0f 85 bb 01 00 00    	jne    8048865 <_Z7run_ssePf+0x245>
 80486aa:	b8 60 b0 04 08       	mov    $0x804b060,%eax
 80486af:	a8 0f                	test   $0xf,%al
 80486b1:	0f 29 0d 50 b0 04 08 	movaps %xmm1,0x804b050
 80486b8:	0f 85 a7 01 00 00    	jne    8048865 <_Z7run_ssePf+0x245>
 80486be:	b8 70 b0 04 08       	mov    $0x804b070,%eax
 80486c3:	a8 0f                	test   $0xf,%al
 80486c5:	0f 29 05 60 b0 04 08 	movaps %xmm0,0x804b060
 80486cc:	0f 85 93 01 00 00    	jne    8048865 <_Z7run_ssePf+0x245>
 80486d2:	be 01 00 00 00       	mov    $0x1,%esi
        transpose(matrix, result);
    }
    print_matrix(matrix);
    print_matrix(result);
}

 80486d7:	8d 46 ff             	lea    -0x1(%esi),%eax

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 80486da:	83 f8 03             	cmp    $0x3,%eax
 80486dd:	0f 29 2d 70 b0 04 08 	movaps %xmm5,0x804b070
 80486e4:	74 51                	je     8048737 <_Z7run_ssePf+0x117>
 80486e6:	d9 43 0c             	flds   0xc(%ebx)
 80486e9:	85 c0                	test   %eax,%eax
 80486eb:	d9 43 08             	flds   0x8(%ebx)
 80486ee:	d9 43 04             	flds   0x4(%ebx)
 80486f1:	d9 03                	flds   (%ebx)
 80486f3:	0f 85 57 01 00 00    	jne    8048850 <_Z7run_ssePf+0x230>
 80486f9:	d9 cb                	fxch   %st(3)
 80486fb:	dd 5c 24 20          	fstpl  0x20(%esp)
 80486ff:	d9 c9                	fxch   %st(1)
 8048701:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048705:	dd 5c 24 10          	fstpl  0x10(%esp)
 8048709:	c7 44 24 28 70 8e 04 	movl   $0x8048e70,0x28(%esp)
 8048710:	08 
 8048711:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048715:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
 804871c:	00 
 804871d:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048724:	e8 73 fd ff ff       	call   804849c <printf@plt>
 8048729:	83 c6 01             	add    $0x1,%esi
 804872c:	83 c3 10             	add    $0x10,%ebx
        transpose(matrix, result);
    }
    print_matrix(matrix);
    print_matrix(result);
}

 804872f:	8d 46 ff             	lea    -0x1(%esi),%eax

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048732:	83 f8 03             	cmp    $0x3,%eax
 8048735:	75 af                	jne    80486e6 <_Z7run_ssePf+0xc6>
 8048737:	d9 43 0c             	flds   0xc(%ebx)
 804873a:	b8 72 8e 04 08       	mov    $0x8048e72,%eax
 804873f:	d9 43 08             	flds   0x8(%ebx)
 8048742:	d9 43 04             	flds   0x4(%ebx)
 8048745:	d9 03                	flds   (%ebx)
 8048747:	d9 cb                	fxch   %st(3)
 8048749:	dd 5c 24 20          	fstpl  0x20(%esp)
 804874d:	d9 c9                	fxch   %st(1)
 804874f:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048753:	dd 5c 24 10          	fstpl  0x10(%esp)
 8048757:	89 44 24 28          	mov    %eax,0x28(%esp)
 804875b:	dd 5c 24 08          	fstpl  0x8(%esp)
 804875f:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 8048766:	00 
 8048767:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 804876e:	e8 29 fd ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048773:	83 fe 03             	cmp    $0x3,%esi
 8048776:	7e b1                	jle    8048729 <_Z7run_ssePf+0x109>
 8048778:	31 f6                	xor    %esi,%esi
 804877a:	31 db                	xor    %ebx,%ebx
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 804877c:	83 fe 03             	cmp    $0x3,%esi
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 804877f:	bf 01 00 00 00       	mov    $0x1,%edi
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048784:	74 5e                	je     80487e4 <_Z7run_ssePf+0x1c4>
 8048786:	d9 83 4c b0 04 08    	flds   0x804b04c(%ebx)
 804878c:	85 f6                	test   %esi,%esi
 804878e:	d9 83 48 b0 04 08    	flds   0x804b048(%ebx)
 8048794:	d9 83 44 b0 04 08    	flds   0x804b044(%ebx)
 804879a:	d9 83 40 b0 04 08    	flds   0x804b040(%ebx)
 80487a0:	0f 85 b6 00 00 00    	jne    804885c <_Z7run_ssePf+0x23c>
 80487a6:	d9 cb                	fxch   %st(3)
 80487a8:	dd 5c 24 20          	fstpl  0x20(%esp)
 80487ac:	d9 c9                	fxch   %st(1)
 80487ae:	dd 5c 24 18          	fstpl  0x18(%esp)
 80487b2:	dd 5c 24 10          	fstpl  0x10(%esp)
 80487b6:	c7 44 24 28 70 8e 04 	movl   $0x8048e70,0x28(%esp)
 80487bd:	08 
 80487be:	dd 5c 24 08          	fstpl  0x8(%esp)
 80487c2:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
 80487c9:	00 
 80487ca:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 80487d1:	e8 c6 fc ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 80487d6:	83 c6 01             	add    $0x1,%esi
 80487d9:	83 c7 01             	add    $0x1,%edi
 80487dc:	83 c3 10             	add    $0x10,%ebx
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 80487df:	83 fe 03             	cmp    $0x3,%esi
 80487e2:	75 a2                	jne    8048786 <_Z7run_ssePf+0x166>
 80487e4:	d9 83 4c b0 04 08    	flds   0x804b04c(%ebx)
 80487ea:	b8 72 8e 04 08       	mov    $0x8048e72,%eax
 80487ef:	d9 83 48 b0 04 08    	flds   0x804b048(%ebx)
 80487f5:	d9 83 44 b0 04 08    	flds   0x804b044(%ebx)
 80487fb:	d9 83 40 b0 04 08    	flds   0x804b040(%ebx)
 8048801:	d9 cb                	fxch   %st(3)
 8048803:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048807:	d9 c9                	fxch   %st(1)
 8048809:	dd 5c 24 18          	fstpl  0x18(%esp)
 804880d:	dd 5c 24 10          	fstpl  0x10(%esp)
 8048811:	89 44 24 28          	mov    %eax,0x28(%esp)
 8048815:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048819:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 8048820:	00 
 8048821:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048828:	e8 6f fc ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 804882d:	83 ff 03             	cmp    $0x3,%edi
 8048830:	7e a4                	jle    80487d6 <_Z7run_ssePf+0x1b6>
        float *ptr = &result[4*a];
        assert((((long)ptr) & 0xf) == 0);
        _mm_store_ps(ptr, matrix_as_sse[a]);
    }
    print_matrix(matrix);
    print_matrix(result);
 8048832:	d9 05 44 b0 04 08    	flds   0x804b044
 8048838:	dd 5c 24 04          	fstpl  0x4(%esp)
 804883c:	c7 04 24 b8 8e 04 08 	movl   $0x8048eb8,(%esp)
 8048843:	e8 54 fc ff ff       	call   804849c <printf@plt>
    printf("value[0] = %f\n", result[1]);
 8048848:	83 c4 3c             	add    $0x3c,%esp
 804884b:	5b                   	pop    %ebx
 804884c:	5e                   	pop    %esi
 804884d:	5f                   	pop    %edi
 804884e:	5d                   	pop    %ebp
 804884f:	c3                   	ret    
 8048850:	d9 cb                	fxch   %st(3)

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048852:	b8 70 8e 04 08       	mov    $0x8048e70,%eax
 8048857:	e9 ed fe ff ff       	jmp    8048749 <_Z7run_ssePf+0x129>
 804885c:	d9 cb                	fxch   %st(3)
 804885e:	b8 70 8e 04 08       	mov    $0x8048e70,%eax
 8048863:	eb 9e                	jmp    8048803 <_Z7run_ssePf+0x1e3>
        sse_transpose(matrix_as_sse);
    }

    // convert back to matrix; each __m128 needs to be 16b aligned
    for (int a = 0; a < 4; a++) {
        float *ptr = &result[4*a];
 8048865:	c7 44 24 0c 3c 8f 04 	movl   $0x8048f3c,0xc(%esp)
 804886c:	08 
 804886d:	c7 44 24 08 4f 00 00 	movl   $0x4f,0x8(%esp)
 8048874:	00 
 8048875:	c7 44 24 04 8e 8e 04 	movl   $0x8048e8e,0x4(%esp)
 804887c:	08 
 804887d:	c7 04 24 9f 8e 04 08 	movl   $0x8048e9f,(%esp)
 8048884:	e8 f3 fb ff ff       	call   804847c <__assert_fail@plt>
 8048889:	90                   	nop    
 804888a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

08048890 <_Z8run_specPf>:
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
               row == 3 ? " ]" : ",");
    }
}

 8048890:	55                   	push   %ebp
 8048891:	89 e5                	mov    %esp,%ebp
 8048893:	57                   	push   %edi
 8048894:	56                   	push   %esi
 8048895:	53                   	push   %ebx
void run_spec(float *matrix) {
 8048896:	31 db                	xor    %ebx,%ebx
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
               row == 3 ? " ]" : ",");
    }
}

 8048898:	83 ec 2c             	sub    $0x2c,%esp
 804889b:	8b 7d 08             	mov    0x8(%ebp),%edi
void run_spec(float *matrix) {
 804889e:	c7 04 24 18 8f 04 08 	movl   $0x8048f18,(%esp)
 80488a5:	e8 02 fc ff ff       	call   80484ac <puts@plt>
    timersub(to, from, &diff); \
    diff.tv_sec + 1e-6 * (float)diff.tv_usec; })

/// specification; separate result matrix is used as memory is
/// usually plentiful (don't need to copy back to mx)
inline void transpose(float *mx, float *result) {
 80488aa:	89 fe                	mov    %edi,%esi
 80488ac:	89 f9                	mov    %edi,%ecx
 80488ae:	31 d2                	xor    %edx,%edx
    for (int x = 0; x < 4; x++)
        for (int y = 0; y < 4; y++)
 80488b0:	8b 01                	mov    (%ecx),%eax
 80488b2:	89 04 95 80 b0 04 08 	mov    %eax,0x804b080(,%edx,4)
 80488b9:	8b 41 10             	mov    0x10(%ecx),%eax
 80488bc:	89 04 95 84 b0 04 08 	mov    %eax,0x804b084(,%edx,4)
 80488c3:	8b 41 20             	mov    0x20(%ecx),%eax
 80488c6:	89 04 95 88 b0 04 08 	mov    %eax,0x804b088(,%edx,4)
 80488cd:	8b 41 30             	mov    0x30(%ecx),%eax
 80488d0:	83 c1 04             	add    $0x4,%ecx
 80488d3:	89 04 95 8c b0 04 08 	mov    %eax,0x804b08c(,%edx,4)
 80488da:	83 c2 04             	add    $0x4,%edx
    timersub(to, from, &diff); \
    diff.tv_sec + 1e-6 * (float)diff.tv_usec; })

/// specification; separate result matrix is used as memory is
/// usually plentiful (don't need to copy back to mx)
inline void transpose(float *mx, float *result) {
 80488dd:	83 fa 10             	cmp    $0x10,%edx
 80488e0:	75 ce                	jne    80488b0 <_Z8run_specPf+0x20>
    }
}

void run_spec(float *matrix) {
    printf("=== Specification calculation ===\n");
    static float result[16] __attribute__ ((aligned(16)));
 80488e2:	83 c3 01             	add    $0x1,%ebx
 80488e5:	81 fb 01 ca 9a 3b    	cmp    $0x3b9aca01,%ebx
 80488eb:	75 bd                	jne    80488aa <_Z8run_specPf+0x1a>
 80488ed:	bb 01 00 00 00       	mov    $0x1,%ebx
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
               row == 3 ? " ]" : ",");
    }
}

 80488f2:	8d 43 ff             	lea    -0x1(%ebx),%eax

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 80488f5:	83 f8 03             	cmp    $0x3,%eax
 80488f8:	74 51                	je     804894b <_Z8run_specPf+0xbb>
 80488fa:	d9 46 0c             	flds   0xc(%esi)
 80488fd:	85 c0                	test   %eax,%eax
 80488ff:	d9 46 08             	flds   0x8(%esi)
 8048902:	d9 46 04             	flds   0x4(%esi)
 8048905:	d9 06                	flds   (%esi)
 8048907:	0f 85 41 01 00 00    	jne    8048a4e <_Z8run_specPf+0x1be>
 804890d:	d9 cb                	fxch   %st(3)
 804890f:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048913:	d9 c9                	fxch   %st(1)
 8048915:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048919:	dd 5c 24 10          	fstpl  0x10(%esp)
 804891d:	c7 44 24 28 70 8e 04 	movl   $0x8048e70,0x28(%esp)
 8048924:	08 
 8048925:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048929:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
 8048930:	00 
 8048931:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048938:	e8 5f fb ff ff       	call   804849c <printf@plt>
    }
}

void run_spec(float *matrix) {
    printf("=== Specification calculation ===\n");
    static float result[16] __attribute__ ((aligned(16)));
 804893d:	83 c3 01             	add    $0x1,%ebx
 8048940:	83 c6 10             	add    $0x10,%esi
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
               row == 3 ? " ]" : ",");
    }
}

 8048943:	8d 43 ff             	lea    -0x1(%ebx),%eax

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048946:	83 f8 03             	cmp    $0x3,%eax
 8048949:	75 af                	jne    80488fa <_Z8run_specPf+0x6a>
 804894b:	d9 46 0c             	flds   0xc(%esi)
 804894e:	b8 72 8e 04 08       	mov    $0x8048e72,%eax
 8048953:	d9 46 08             	flds   0x8(%esi)
 8048956:	d9 46 04             	flds   0x4(%esi)
 8048959:	d9 06                	flds   (%esi)
 804895b:	d9 cb                	fxch   %st(3)
 804895d:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048961:	d9 c9                	fxch   %st(1)
 8048963:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048967:	dd 5c 24 10          	fstpl  0x10(%esp)
 804896b:	89 44 24 28          	mov    %eax,0x28(%esp)
 804896f:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048973:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 804897a:	00 
 804897b:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048982:	e8 15 fb ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048987:	83 fb 03             	cmp    $0x3,%ebx
 804898a:	7e b1                	jle    804893d <_Z8run_specPf+0xad>
 804898c:	31 f6                	xor    %esi,%esi
 804898e:	31 db                	xor    %ebx,%ebx
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048990:	83 fe 03             	cmp    $0x3,%esi
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048993:	bf 01 00 00 00       	mov    $0x1,%edi
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048998:	74 5e                	je     80489f8 <_Z8run_specPf+0x168>
 804899a:	d9 83 8c b0 04 08    	flds   0x804b08c(%ebx)
 80489a0:	85 f6                	test   %esi,%esi
 80489a2:	d9 83 88 b0 04 08    	flds   0x804b088(%ebx)
 80489a8:	d9 83 84 b0 04 08    	flds   0x804b084(%ebx)
 80489ae:	d9 83 80 b0 04 08    	flds   0x804b080(%ebx)
 80489b4:	0f 85 a0 00 00 00    	jne    8048a5a <_Z8run_specPf+0x1ca>
 80489ba:	d9 cb                	fxch   %st(3)
 80489bc:	dd 5c 24 20          	fstpl  0x20(%esp)
 80489c0:	d9 c9                	fxch   %st(1)
 80489c2:	dd 5c 24 18          	fstpl  0x18(%esp)
 80489c6:	dd 5c 24 10          	fstpl  0x10(%esp)
 80489ca:	c7 44 24 28 70 8e 04 	movl   $0x8048e70,0x28(%esp)
 80489d1:	08 
 80489d2:	dd 5c 24 08          	fstpl  0x8(%esp)
 80489d6:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
 80489dd:	00 
 80489de:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 80489e5:	e8 b2 fa ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 80489ea:	83 c6 01             	add    $0x1,%esi
 80489ed:	83 c7 01             	add    $0x1,%edi
 80489f0:	83 c3 10             	add    $0x10,%ebx
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 80489f3:	83 fe 03             	cmp    $0x3,%esi
 80489f6:	75 a2                	jne    804899a <_Z8run_specPf+0x10a>
 80489f8:	d9 83 8c b0 04 08    	flds   0x804b08c(%ebx)
 80489fe:	b8 72 8e 04 08       	mov    $0x8048e72,%eax
 8048a03:	d9 83 88 b0 04 08    	flds   0x804b088(%ebx)
 8048a09:	d9 83 84 b0 04 08    	flds   0x804b084(%ebx)
 8048a0f:	d9 83 80 b0 04 08    	flds   0x804b080(%ebx)
 8048a15:	d9 cb                	fxch   %st(3)
 8048a17:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048a1b:	d9 c9                	fxch   %st(1)
 8048a1d:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048a21:	dd 5c 24 10          	fstpl  0x10(%esp)
 8048a25:	89 44 24 28          	mov    %eax,0x28(%esp)
 8048a29:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048a2d:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 8048a34:	00 
 8048a35:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048a3c:	e8 5b fa ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048a41:	83 ff 03             	cmp    $0x3,%edi
 8048a44:	7e a4                	jle    80489ea <_Z8run_specPf+0x15a>
    static float result[16] __attribute__ ((aligned(16)));
    for (int a = 0; a < NUM_TRIALS; a++) {
        transpose(matrix, result);
    }
    print_matrix(matrix);
    print_matrix(result);
 8048a46:	83 c4 2c             	add    $0x2c,%esp
 8048a49:	5b                   	pop    %ebx
 8048a4a:	5e                   	pop    %esi
 8048a4b:	5f                   	pop    %edi
 8048a4c:	5d                   	pop    %ebp
 8048a4d:	c3                   	ret    
 8048a4e:	d9 cb                	fxch   %st(3)

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048a50:	b8 70 8e 04 08       	mov    $0x8048e70,%eax
 8048a55:	e9 03 ff ff ff       	jmp    804895d <_Z8run_specPf+0xcd>
 8048a5a:	d9 cb                	fxch   %st(3)
 8048a5c:	b8 70 8e 04 08       	mov    $0x8048e70,%eax
 8048a61:	eb b4                	jmp    8048a17 <_Z8run_specPf+0x187>
 8048a63:	90                   	nop    
 8048a64:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8048a6a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08048a70 <main>:
    }
    print_matrix(matrix);
    print_matrix(result);
    printf("value[0] = %f\n", result[1]);
}

 8048a70:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 8048a74:	83 e4 f0             	and    $0xfffffff0,%esp
 8048a77:	ff 71 fc             	pushl  -0x4(%ecx)
 8048a7a:	55                   	push   %ebp
 8048a7b:	89 e5                	mov    %esp,%ebp
 8048a7d:	57                   	push   %edi
 8048a7e:	56                   	push   %esi
 8048a7f:	53                   	push   %ebx
 8048a80:	51                   	push   %ecx
 8048a81:	81 ec a8 00 00 00    	sub    $0xa8,%esp
    // NOTE - need to align 16 so conversion to __m128 to float works
    float matrix[16] __attribute__ ((aligned(16)));
    for (int a = 0; a < 16; a++) {
        matrix[a] = a;
    }
    struct timeval begin, spec_end, sse_end;
 8048a87:	8d 45 e0             	lea    -0x20(%ebp),%eax
}

int main() {
    // NOTE - need to align 16 so conversion to __m128 to float works
    float matrix[16] __attribute__ ((aligned(16)));
    for (int a = 0; a < 16; a++) {
 8048a8a:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
 8048a91:	8d 5d 88             	lea    -0x78(%ebp),%ebx
 8048a94:	c7 45 8c 00 00 80 3f 	movl   $0x3f800000,-0x74(%ebp)
 8048a9b:	c7 45 90 00 00 00 40 	movl   $0x40000000,-0x70(%ebp)
 8048aa2:	c7 45 94 00 00 40 40 	movl   $0x40400000,-0x6c(%ebp)
 8048aa9:	c7 45 98 00 00 80 40 	movl   $0x40800000,-0x68(%ebp)
 8048ab0:	c7 45 9c 00 00 a0 40 	movl   $0x40a00000,-0x64(%ebp)
 8048ab7:	c7 45 a0 00 00 c0 40 	movl   $0x40c00000,-0x60(%ebp)
 8048abe:	c7 45 a4 00 00 e0 40 	movl   $0x40e00000,-0x5c(%ebp)
 8048ac5:	c7 45 a8 00 00 00 41 	movl   $0x41000000,-0x58(%ebp)
 8048acc:	c7 45 ac 00 00 10 41 	movl   $0x41100000,-0x54(%ebp)
 8048ad3:	c7 45 b0 00 00 20 41 	movl   $0x41200000,-0x50(%ebp)
 8048ada:	c7 45 b4 00 00 30 41 	movl   $0x41300000,-0x4c(%ebp)
 8048ae1:	c7 45 b8 00 00 40 41 	movl   $0x41400000,-0x48(%ebp)
 8048ae8:	c7 45 bc 00 00 50 41 	movl   $0x41500000,-0x44(%ebp)
 8048aef:	c7 45 c0 00 00 60 41 	movl   $0x41600000,-0x40(%ebp)
 8048af6:	c7 45 c4 00 00 70 41 	movl   $0x41700000,-0x3c(%ebp)
        matrix[a] = a;
    }
    struct timeval begin, spec_end, sse_end;
 8048afd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048b04:	00 
 8048b05:	89 04 24             	mov    %eax,(%esp)
 8048b08:	e8 7f f9 ff ff       	call   804848c <gettimeofday@plt>
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
               row == 3 ? " ]" : ",");
    }
}

void run_spec(float *matrix) {
 8048b0d:	c7 04 24 18 8f 04 08 	movl   $0x8048f18,(%esp)
 8048b14:	e8 93 f9 ff ff       	call   80484ac <puts@plt>
 8048b19:	31 c9                	xor    %ecx,%ecx
    timersub(to, from, &diff); \
    diff.tv_sec + 1e-6 * (float)diff.tv_usec; })

/// specification; separate result matrix is used as memory is
/// usually plentiful (don't need to copy back to mx)
inline void transpose(float *mx, float *result) {
 8048b1b:	31 d2                	xor    %edx,%edx
 8048b1d:	8d 76 00             	lea    0x0(%esi),%esi
    for (int x = 0; x < 4; x++)
        for (int y = 0; y < 4; y++)
 8048b20:	8b 04 1a             	mov    (%edx,%ebx,1),%eax
 8048b23:	89 04 95 80 b0 04 08 	mov    %eax,0x804b080(,%edx,4)
 8048b2a:	8b 44 1a 10          	mov    0x10(%edx,%ebx,1),%eax
 8048b2e:	89 04 95 84 b0 04 08 	mov    %eax,0x804b084(,%edx,4)
 8048b35:	8b 44 1a 20          	mov    0x20(%edx,%ebx,1),%eax
 8048b39:	89 04 95 88 b0 04 08 	mov    %eax,0x804b088(,%edx,4)
 8048b40:	8b 44 1a 30          	mov    0x30(%edx,%ebx,1),%eax
 8048b44:	89 04 95 8c b0 04 08 	mov    %eax,0x804b08c(,%edx,4)
 8048b4b:	83 c2 04             	add    $0x4,%edx
    timersub(to, from, &diff); \
    diff.tv_sec + 1e-6 * (float)diff.tv_usec; })

/// specification; separate result matrix is used as memory is
/// usually plentiful (don't need to copy back to mx)
inline void transpose(float *mx, float *result) {
 8048b4e:	83 fa 10             	cmp    $0x10,%edx
 8048b51:	75 cd                	jne    8048b20 <main+0xb0>
    }
}

void run_spec(float *matrix) {
    printf("=== Specification calculation ===\n");
    static float result[16] __attribute__ ((aligned(16)));
 8048b53:	83 c1 01             	add    $0x1,%ecx
 8048b56:	81 f9 01 ca 9a 3b    	cmp    $0x3b9aca01,%ecx
 8048b5c:	75 bd                	jne    8048b1b <main+0xab>
 8048b5e:	c7 45 84 00 00 00 00 	movl   $0x0,-0x7c(%ebp)
 8048b65:	8d 75 94             	lea    -0x6c(%ebp),%esi
 8048b68:	bf 01 00 00 00       	mov    $0x1,%edi

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048b6d:	83 7d 84 03          	cmpl   $0x3,-0x7c(%ebp)
 8048b71:	74 56                	je     8048bc9 <main+0x159>
 8048b73:	8b 45 84             	mov    -0x7c(%ebp),%eax
 8048b76:	d9 06                	flds   (%esi)
 8048b78:	d9 46 fc             	flds   -0x4(%esi)
 8048b7b:	d9 46 f8             	flds   -0x8(%esi)
 8048b7e:	85 c0                	test   %eax,%eax
 8048b80:	d9 46 f4             	flds   -0xc(%esi)
 8048b83:	0f 85 f4 01 00 00    	jne    8048d7d <main+0x30d>
 8048b89:	d9 cb                	fxch   %st(3)
 8048b8b:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048b8f:	d9 c9                	fxch   %st(1)
 8048b91:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048b95:	dd 5c 24 10          	fstpl  0x10(%esp)
 8048b99:	c7 44 24 28 70 8e 04 	movl   $0x8048e70,0x28(%esp)
 8048ba0:	08 
 8048ba1:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048ba5:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
 8048bac:	00 
 8048bad:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048bb4:	e8 e3 f8 ff ff       	call   804849c <printf@plt>
    }
}

void run_spec(float *matrix) {
    printf("=== Specification calculation ===\n");
    static float result[16] __attribute__ ((aligned(16)));
 8048bb9:	83 45 84 01          	addl   $0x1,-0x7c(%ebp)
 8048bbd:	83 c7 01             	add    $0x1,%edi
 8048bc0:	83 c6 10             	add    $0x10,%esi

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048bc3:	83 7d 84 03          	cmpl   $0x3,-0x7c(%ebp)
 8048bc7:	75 aa                	jne    8048b73 <main+0x103>
 8048bc9:	d9 06                	flds   (%esi)
 8048bcb:	b8 72 8e 04 08       	mov    $0x8048e72,%eax
 8048bd0:	d9 46 fc             	flds   -0x4(%esi)
 8048bd3:	d9 46 f8             	flds   -0x8(%esi)
 8048bd6:	d9 46 f4             	flds   -0xc(%esi)
 8048bd9:	d9 cb                	fxch   %st(3)
 8048bdb:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048bdf:	d9 c9                	fxch   %st(1)
 8048be1:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048be5:	dd 5c 24 10          	fstpl  0x10(%esp)
 8048be9:	89 44 24 28          	mov    %eax,0x28(%esp)
 8048bed:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048bf1:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 8048bf8:	00 
 8048bf9:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048c00:	e8 97 f8 ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048c05:	83 ff 03             	cmp    $0x3,%edi
 8048c08:	7e af                	jle    8048bb9 <main+0x149>
 8048c0a:	31 ff                	xor    %edi,%edi
 8048c0c:	31 f6                	xor    %esi,%esi
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048c0e:	83 ff 03             	cmp    $0x3,%edi
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048c11:	c7 45 80 01 00 00 00 	movl   $0x1,-0x80(%ebp)
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048c18:	74 5f                	je     8048c79 <main+0x209>
 8048c1a:	d9 86 8c b0 04 08    	flds   0x804b08c(%esi)
 8048c20:	85 ff                	test   %edi,%edi
 8048c22:	d9 86 88 b0 04 08    	flds   0x804b088(%esi)
 8048c28:	d9 86 84 b0 04 08    	flds   0x804b084(%esi)
 8048c2e:	d9 86 80 b0 04 08    	flds   0x804b080(%esi)
 8048c34:	0f 85 4f 01 00 00    	jne    8048d89 <main+0x319>
 8048c3a:	d9 cb                	fxch   %st(3)
 8048c3c:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048c40:	d9 c9                	fxch   %st(1)
 8048c42:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048c46:	dd 5c 24 10          	fstpl  0x10(%esp)
 8048c4a:	c7 44 24 28 70 8e 04 	movl   $0x8048e70,0x28(%esp)
 8048c51:	08 
 8048c52:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048c56:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
 8048c5d:	00 
 8048c5e:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048c65:	e8 32 f8 ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048c6a:	83 c7 01             	add    $0x1,%edi
 8048c6d:	83 c6 10             	add    $0x10,%esi
 8048c70:	83 45 80 01          	addl   $0x1,-0x80(%ebp)
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048c74:	83 ff 03             	cmp    $0x3,%edi
 8048c77:	75 a1                	jne    8048c1a <main+0x1aa>
 8048c79:	d9 86 8c b0 04 08    	flds   0x804b08c(%esi)
 8048c7f:	b8 72 8e 04 08       	mov    $0x8048e72,%eax
 8048c84:	d9 86 88 b0 04 08    	flds   0x804b088(%esi)
 8048c8a:	d9 86 84 b0 04 08    	flds   0x804b084(%esi)
 8048c90:	d9 86 80 b0 04 08    	flds   0x804b080(%esi)
 8048c96:	d9 cb                	fxch   %st(3)
 8048c98:	dd 5c 24 20          	fstpl  0x20(%esp)
 8048c9c:	d9 c9                	fxch   %st(1)
 8048c9e:	dd 5c 24 18          	fstpl  0x18(%esp)
 8048ca2:	dd 5c 24 10          	fstpl  0x10(%esp)
 8048ca6:	89 44 24 28          	mov    %eax,0x28(%esp)
 8048caa:	dd 5c 24 08          	fstpl  0x8(%esp)
 8048cae:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 8048cb5:	00 
 8048cb6:	c7 04 24 f4 8e 04 08 	movl   $0x8048ef4,(%esp)
 8048cbd:	e8 da f7 ff ff       	call   804849c <printf@plt>
    in[0]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(0, 3, 2, 1));
    in[2]   = SSE_SHUFFLE(tmp[1], tmp[0], SHUFFLE_BITS(1, 2, 3, 0));
    in[1]   = SSE_SHUFFLE(tmp[3], tmp[2], SHUFFLE_BITS(2, 1, 2, 1));
}

void print_matrix(float *m) {
 8048cc2:	83 7d 80 03          	cmpl   $0x3,-0x80(%ebp)
 8048cc6:	7e a2                	jle    8048c6a <main+0x1fa>
    for (int a = 0; a < 16; a++) {
        matrix[a] = a;
    }
    struct timeval begin, spec_end, sse_end;
    gettimeofday(&begin, NULL);
    run_spec(matrix);
 8048cc8:	8d 45 d8             	lea    -0x28(%ebp),%eax
 8048ccb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048cd2:	00 
 8048cd3:	89 04 24             	mov    %eax,(%esp)
 8048cd6:	e8 b1 f7 ff ff       	call   804848c <gettimeofday@plt>
    gettimeofday(&spec_end, NULL);
 8048cdb:	89 1c 24             	mov    %ebx,(%esp)
 8048cde:	e8 3d f9 ff ff       	call   8048620 <_Z7run_ssePf>
    run_sse(matrix);
 8048ce3:	8d 45 d0             	lea    -0x30(%ebp),%eax
 8048ce6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048ced:	00 
 8048cee:	89 04 24             	mov    %eax,(%esp)
 8048cf1:	e8 96 f7 ff ff       	call   804848c <gettimeofday@plt>
    gettimeofday(&sse_end, NULL);
 8048cf6:	8b 55 d8             	mov    -0x28(%ebp),%edx
 8048cf9:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048cfc:	2b 55 e0             	sub    -0x20(%ebp),%edx
 8048cff:	2b 45 e4             	sub    -0x1c(%ebp),%eax
 8048d02:	0f 88 8d 00 00 00    	js     8048d95 <main+0x325>
 8048d08:	52                   	push   %edx
 8048d09:	db 04 24             	fildl  (%esp)
 8048d0c:	89 04 24             	mov    %eax,(%esp)
 8048d0f:	db 04 24             	fildl  (%esp)
 8048d12:	83 c4 04             	add    $0x4,%esp
 8048d15:	dd 05 58 8f 04 08    	fldl   0x8048f58
 8048d1b:	de c9                	fmulp  %st,%st(1)
 8048d1d:	c7 04 24 c7 8e 04 08 	movl   $0x8048ec7,(%esp)
 8048d24:	de c1                	faddp  %st,%st(1)
 8048d26:	dd 5c 24 04          	fstpl  0x4(%esp)
 8048d2a:	e8 6d f7 ff ff       	call   804849c <printf@plt>
    printf("spec time   = %6.2f\n", FLOAT_SECS(&begin, &spec_end));
 8048d2f:	8b 55 d0             	mov    -0x30(%ebp),%edx
 8048d32:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8048d35:	2b 55 d8             	sub    -0x28(%ebp),%edx
 8048d38:	2b 45 dc             	sub    -0x24(%ebp),%eax
 8048d3b:	79 08                	jns    8048d45 <main+0x2d5>
 8048d3d:	83 ea 01             	sub    $0x1,%edx
 8048d40:	05 40 42 0f 00       	add    $0xf4240,%eax
 8048d45:	52                   	push   %edx
 8048d46:	db 04 24             	fildl  (%esp)
 8048d49:	89 04 24             	mov    %eax,(%esp)
 8048d4c:	db 04 24             	fildl  (%esp)
 8048d4f:	83 c4 04             	add    $0x4,%esp
 8048d52:	dd 05 58 8f 04 08    	fldl   0x8048f58
 8048d58:	de c9                	fmulp  %st,%st(1)
 8048d5a:	c7 04 24 dc 8e 04 08 	movl   $0x8048edc,(%esp)
 8048d61:	de c1                	faddp  %st,%st(1)
 8048d63:	dd 5c 24 04          	fstpl  0x4(%esp)
 8048d67:	e8 30 f7 ff ff       	call   804849c <printf@plt>
    printf("sse time    = %6.2f\n", FLOAT_SECS(&spec_end, &sse_end));
 8048d6c:	81 c4 a8 00 00 00    	add    $0xa8,%esp
 8048d72:	31 c0                	xor    %eax,%eax
 8048d74:	59                   	pop    %ecx
 8048d75:	5b                   	pop    %ebx
 8048d76:	5e                   	pop    %esi
 8048d77:	5f                   	pop    %edi
 8048d78:	5d                   	pop    %ebp
 8048d79:	8d 61 fc             	lea    -0x4(%ecx),%esp
 8048d7c:	c3                   	ret    
 8048d7d:	d9 cb                	fxch   %st(3)

void print_matrix(float *m) {
    for (int row = 0; row < 4; row++) {
        printf("%c%4.1f   %4.1f   %4.1f   %4.1f%s\n",
               row == 0 ? '[' : ' ',
               m[4*row], m[4*row + 1], m[4*row + 2], m[4*row + 3],
 8048d7f:	b8 70 8e 04 08       	mov    $0x8048e70,%eax
 8048d84:	e9 52 fe ff ff       	jmp    8048bdb <main+0x16b>
 8048d89:	d9 cb                	fxch   %st(3)
 8048d8b:	b8 70 8e 04 08       	mov    $0x8048e70,%eax
 8048d90:	e9 03 ff ff ff       	jmp    8048c98 <main+0x228>
    struct timeval begin, spec_end, sse_end;
    gettimeofday(&begin, NULL);
    run_spec(matrix);
    gettimeofday(&spec_end, NULL);
    run_sse(matrix);
    gettimeofday(&sse_end, NULL);
 8048d95:	83 ea 01             	sub    $0x1,%edx
 8048d98:	05 40 42 0f 00       	add    $0xf4240,%eax
 8048d9d:	e9 66 ff ff ff       	jmp    8048d08 <main+0x298>
 8048da2:	90                   	nop    
 8048da3:	90                   	nop    
 8048da4:	90                   	nop    
 8048da5:	90                   	nop    
 8048da6:	90                   	nop    
 8048da7:	90                   	nop    
 8048da8:	90                   	nop    
 8048da9:	90                   	nop    
 8048daa:	90                   	nop    
 8048dab:	90                   	nop    
 8048dac:	90                   	nop    
 8048dad:	90                   	nop    
 8048dae:	90                   	nop    
 8048daf:	90                   	nop    

08048db0 <__libc_csu_fini>:
 8048db0:	55                   	push   %ebp
 8048db1:	89 e5                	mov    %esp,%ebp
 8048db3:	5d                   	pop    %ebp
 8048db4:	c3                   	ret    
 8048db5:	8d 74 26 00          	lea    0x0(%esi),%esi
 8048db9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

08048dc0 <__libc_csu_init>:
 8048dc0:	55                   	push   %ebp
 8048dc1:	89 e5                	mov    %esp,%ebp
 8048dc3:	57                   	push   %edi
 8048dc4:	56                   	push   %esi
 8048dc5:	53                   	push   %ebx
 8048dc6:	e8 4f 00 00 00       	call   8048e1a <__i686.get_pc_thunk.bx>
 8048dcb:	81 c3 29 22 00 00    	add    $0x2229,%ebx
 8048dd1:	83 ec 0c             	sub    $0xc,%esp
 8048dd4:	e8 43 f6 ff ff       	call   804841c <_init>
 8048dd9:	8d bb 00 ff ff ff    	lea    -0x100(%ebx),%edi
 8048ddf:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
 8048de5:	29 c7                	sub    %eax,%edi
 8048de7:	c1 ff 02             	sar    $0x2,%edi
 8048dea:	85 ff                	test   %edi,%edi
 8048dec:	74 24                	je     8048e12 <__libc_csu_init+0x52>
 8048dee:	31 f6                	xor    %esi,%esi
 8048df0:	8b 45 10             	mov    0x10(%ebp),%eax
 8048df3:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048df7:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048dfa:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048dfe:	8b 45 08             	mov    0x8(%ebp),%eax
 8048e01:	89 04 24             	mov    %eax,(%esp)
 8048e04:	ff 94 b3 00 ff ff ff 	call   *-0x100(%ebx,%esi,4)
 8048e0b:	83 c6 01             	add    $0x1,%esi
 8048e0e:	39 f7                	cmp    %esi,%edi
 8048e10:	75 de                	jne    8048df0 <__libc_csu_init+0x30>
 8048e12:	83 c4 0c             	add    $0xc,%esp
 8048e15:	5b                   	pop    %ebx
 8048e16:	5e                   	pop    %esi
 8048e17:	5f                   	pop    %edi
 8048e18:	5d                   	pop    %ebp
 8048e19:	c3                   	ret    

08048e1a <__i686.get_pc_thunk.bx>:
 8048e1a:	8b 1c 24             	mov    (%esp),%ebx
 8048e1d:	c3                   	ret    
 8048e1e:	90                   	nop    
 8048e1f:	90                   	nop    

08048e20 <__do_global_ctors_aux>:
 8048e20:	55                   	push   %ebp
 8048e21:	89 e5                	mov    %esp,%ebp
 8048e23:	53                   	push   %ebx
 8048e24:	83 ec 04             	sub    $0x4,%esp
 8048e27:	a1 f4 ae 04 08       	mov    0x804aef4,%eax
 8048e2c:	83 f8 ff             	cmp    $0xffffffff,%eax
 8048e2f:	74 12                	je     8048e43 <__do_global_ctors_aux+0x23>
 8048e31:	31 db                	xor    %ebx,%ebx
 8048e33:	ff d0                	call   *%eax
 8048e35:	8b 83 f0 ae 04 08    	mov    0x804aef0(%ebx),%eax
 8048e3b:	83 eb 04             	sub    $0x4,%ebx
 8048e3e:	83 f8 ff             	cmp    $0xffffffff,%eax
 8048e41:	75 f0                	jne    8048e33 <__do_global_ctors_aux+0x13>
 8048e43:	83 c4 04             	add    $0x4,%esp
 8048e46:	5b                   	pop    %ebx
 8048e47:	5d                   	pop    %ebp
 8048e48:	c3                   	ret    
 8048e49:	90                   	nop    
 8048e4a:	90                   	nop    
 8048e4b:	90                   	nop    
Disassembly of section .fini:

08048e4c <_fini>:
 8048e4c:	55                   	push   %ebp
 8048e4d:	89 e5                	mov    %esp,%ebp
 8048e4f:	53                   	push   %ebx
 8048e50:	83 ec 04             	sub    $0x4,%esp
 8048e53:	e8 00 00 00 00       	call   8048e58 <_fini+0xc>
 8048e58:	5b                   	pop    %ebx
 8048e59:	81 c3 9c 21 00 00    	add    $0x219c,%ebx
 8048e5f:	e8 9c f6 ff ff       	call   8048500 <__do_global_dtors_aux>
 8048e64:	59                   	pop    %ecx
 8048e65:	5b                   	pop    %ebx
 8048e66:	c9                   	leave  
 8048e67:	c3                   	ret    
