/**
 * This example provides a nice case study of the use of generators to produce 
 * complicated expressions. It also illustrates how one can synthesize code for fixed 
 * word sizes, and produce code that actually works for arbitrary sizes.
 * 
 * Recursion control is very important for this example. Using --inlineamnt > 5 for this 
 * example will cause it to run for a very very long time.
 * 
 * 
 */

int N = 4;
int No2 = N/2;

int[N] sort(int[N] input){
	int[N] output=input;
	int[N] done = 0;
	int k=0;
	for(int i=0; i<N; ++i){
		for(int j=i+1; j<N; ++j){
			if( output[j]< output[i]){
				int tmp = output[j];
				output[j] = output[i];
				output[i] = tmp;
			}
		}
	}
	return output;
}


int[No2] sortNover2(int[No2] input){
	int[No2] output=input;
	int[No2] done = 0;
	int k=0;
	for(int i=0; i<No2; ++i){
		for(int j=i+1; j<No2; ++j){
			if( output[j]< output[i]){
				int tmp = output[j];
				output[j] = output[i];
				output[i] = tmp;
			}
		}
	}
	return output;
}


int chose(int[No2] arr1, int idx1,  int[No2] arr2, int idx2, int x3, int x4){
	int t2 = ??;
	int rv = 0;
	if( t2== 0){ rv = idx1; }
	if( t2== 1){ rv = idx2; }
	if( t2== 2){ rv = arr1[idx1]; assert idx1<No2; }
	if( t2== 3){ rv = arr2[idx2]; assert idx2<No2; }
	if( t2== 4){ rv = x3; }
	if( t2== 5){ rv = x4;	}
	assert t2 <= 5;
	return rv;
}

bit generator(int[No2] arr1, int idx1,  int[No2] arr2, int idx2, int x3, int x4){
	int t = ??;
	bit rv = 0;
	if( t==0){
		bit x = generator(arr1, idx1, arr2, idx2, x3, x4);
		if(x){
			rv = generator(arr1, idx1, arr2, idx2, x3, x4);
		}
	}
	if( t==1){
		rv = !generator(arr1, idx1, arr2, idx2, x3, x4);
	}
	if( t==2){
		rv = chose(arr1, idx1, arr2, idx2, x3, x4) < chose(arr1, idx1, arr2, idx2, x3, x4);
	}
	assert t <= 2;
	return rv;
}

int[N] MergeSort(int[N] input)implements sort{
	int[N] output;
	if(N>1){ 
		int[No2] firstHalf = input[0::No2];
		int[No2] secondHalf = input[No2::No2];
		firstHalf = sortNover2(firstHalf);
		secondHalf = sortNover2(secondHalf);
		int x=0;
		int y=0;
		for(int i=0; i<N; ++i){
			//  
			
			    bit rv_16 = 0;
			    bit rv_17 = 0;
			    bit rv_18 = 0;
			    bit rv_19 = 0;
			    if (x < 2) {	      
			      rv_19 = firstHalf[x] < x;
			    }
			    rv_18 = !rv_19;
			    if (rv_18) {
			      bit rv_23 = 0;
			      bit rv_24 = y < 2;
			      if (rv_24) {
			        bit rv_25 = 0;
			        bit rv_26 = 0;
			        int rv_27 = secondHalf[y];
			        rv_26 = x < rv_27;
			        rv_25 = !rv_26;
			        rv_23 = rv_25;
			      }
			      rv_17 = rv_23;
			    }
			    rv_16 = !rv_17;			
			if(rv_16 ){
				assert x < 2;
				output[i] = firstHalf[x]; x = x+1;
			}else{
				assert y<2;
				output[i] = secondHalf[y]; y = y+1;
			}
		}
	}else{
		output[0] = input[0];	
	}
	return output;
}


