#include "test/flop/floatAdd.skh"
#include "test/flop/floatMul.skh"

bit[FW] FObitsub(bit[FW] a, bit[FW] b)
{
	for(int i=0;i<FW;i++)
		b[i]=!b[i];
	bit[FW] one=0;
	one[0]=1;
	b=b+a;
	return b+one;
}

bit[FW] floatDiv2(bit[FW] a)
{
	bit[E] e=a[M::E];
	bit[E] n_one=0;
	for(int i=0;i<E;i++)
		n_one[i]=1;
	a[M::E]=e+n_one;
	return a;
}

bit[FW] floatAbs(bit[FW] a)
{
	a[SB]=0;
	return a;
}

bit[FW] isqrt(bit[FW] in)
{
	bit[FW] t=??;
//	if(??)
		t=FObitsub(t,(in<<1));
//	else
//		t=t-in;

//	bit[FW] t=0; //(in<<1) {|} (in);
//	bit[FW] mm=??;
//	bit[FW] ins=in<<1;
//	for(int i=0;i<FW;i++)
//		if(mm[i]) t[i]=ins[i]; else t[i]=in[i];
	
	t[M-1]=1;
	bit[FW] half=floatDiv2(floatOne()); // = 0.5
	bit[FW] th=floatOne(); th[M-2]=1; // = 1.5
	bit[FW] hxx=floatMul(floatMul(half,in),floatMul(t,t));
	hxx[SB]=1; //negate
	return floatMul(t,floatAdd(th,hxx));
}

bit alwaysOne(bit[FW] in)
{
	return 1;
}

bit equiv(bit[FW] in) implements alwaysOne
{
//	in=floatOne(); in[2]=1; in[5]=1; in[6]=1; //=96
	in[SB]=0;
	in[M-1]=1;
	bit[FW] one=floatOne();
	bit[FW] s=isqrt(in);
	bit[FW] m=floatMul(s,s);
	m=floatMul(m,in);
	m[SB]=1;
	bit[FW] dif=floatAdd(m,one); //computes 1-in*s^2
	bit[FW] ub=floatOne(); ub[SB-2]=1; //=16
	bit[FW] lb=floatOne(); lb[SB-1]=0; lb[SB-2]=1; //=1/16
	bit[FW] eps=floatDiv2(floatDiv2(floatOne())); eps[0]=1;
//	bit[FW] eps=floatDiv2(floatOne()); eps[M-4]=1;
	if(floatAbsLess(lb,s) && floatAbsLess(s,ub) && floatAbsLess(dif,eps))
		return 1;
	else
		return 0;
}
