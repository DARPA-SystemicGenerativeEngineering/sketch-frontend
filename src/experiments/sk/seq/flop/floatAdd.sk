int M=4;
int E=4;
int SB=M+E;
int FW=M+E+1;
int log_M=2;

bit[FW] floatOne()
{
	bit[FW] ret=0;
	ret[SB-1]=1;
	ret[M-1]=1;
	return ret;
}

bit[E] FOnegateE(bit[E] x)
{
	bit[E] ret;
	for(int i=0;i<E;i++)
		ret[i]=!x[i];
	return ret;
}

bit[E] FOsubtractE(bit[E] e1, bit[E] e2)
{
	bit[E] ret=FOnegateE(e2);
	ret=ret+e1;
	bit[E] one=0;
	one[0]=1;
	return ret+one;
}

bit[M+1] FOtwocomp(bit[M+1] x)
{
	bit[M+1] ret;
	for(int i=0;i<M+1;i++)
		ret[i]=!x[i];
	bit[M+1] one=0;
	one[0]=1;
	return ret+one;
}

bit floatIsZero(bit[FW] x)
{
	return !x[M-1];
}

bit floatAbsLess(bit[FW] a, bit[FW] b)
{
    bit ret=0;
	bit eq=1;
	if(!a[M-1]) //a==0
		ret=1;
	else {
	    for(int i=M+E-1;i>=0;i--) {
			if(eq && a[i]!=b[i]) {
				ret=b[i];
				eq=0;
			}
	    }
    }
    return ret;
}

bit[FW] FOadd(bit[FW] a, bit[FW] b)
{
	/* we assume a>=b */
	bit[FW] ret=0;
	bit[E] one=0;
	one[0]=1;
	
	bit difsign=a[SB]^b[SB];
	bit[E] e1=a[M::E];
	bit[E] e2=b[M::E];
	bit[E] edif=FOsubtractE(e1,e2);
	bit over=0;
	for(int i=log_M;i<E;i++) {
		if(edif[i]) 
			over=1;
	}
	int sh=0;
	int t=1;
	for(int i=0;i<log_M;i++) {
		if(edif[i])
			sh=sh+t;
		t=t*2;
	}
	if(over || sh>=M) //the 2nd number is too small (insignificant)
		ret=a;
	else {
		bit[M+1] m1=0;
		bit[M+1] m2=0;
		m1[0::M]=a[0::M];
		m2[0::M]=b[0::M];
		m2=m2<<sh;
		if(difsign) m2=FOtwocomp(m2);
		m1=m1+m2;
		if(m1[M]) {
			ret[0::M]=m1[1::M];
			ret[M::E]=e1+one;
		}
		else {
			ret[0::M]=m1[0::M];
			ret[M::E]=e1;
		}
	}
	ret[SB]=a[SB];
	return ret;
}

bit[FW] floatAdd(bit[FW] a, bit[FW] b) 
{
	bit[FW] ret=0;

	if(floatIsZero(a))
		ret=b;
	else if(floatIsZero(b))
		ret=a;
	else if(floatAbsLess(a,b)) {
		ret=FOadd(b,a);
	}
	else {
		/* a>=b */
		ret=FOadd(a,b);
	}
	return ret;
}

bit[FW] test()
{
	bit[FW] c=floatOne();
	c[2]=1; c[5]=1; c[6]=1;   // == 96
	return c;
}

bit[FW] test2() implements test
{
	bit[FW] a=floatOne();
//	a[2]=1; a[5]=1;   // == 6
	a[1]=1; a[6]=1;   // == 20
	bit[FW] b=??;
	return floatAdd(a,b);
}
