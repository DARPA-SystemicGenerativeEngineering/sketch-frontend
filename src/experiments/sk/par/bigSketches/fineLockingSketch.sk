#include "parTest/bigSketches/llset.skh"


Node gnext(Node n){
	Node rv = null;
	if(??){
		if(??){
			rv = n;
		}else{
			assert n != null;
			rv = n.next;	
		}
	}else{
		rv = gnext(n);	
	}
	return rv;
}


Node sel(Node n1, Node n2, Node n3){
	Node rv = null;
	if(??){
		if(??){
			rv = n1;	
		}else{
			rv = n2;	
		}
	}else{
		rv = n3;
	}
	return gnext(rv);
}



bit comp(Node n1, Node n2, Node n3){
	bit t= 0;
	if(??){
		t = sel(n1, n2, n3) == sel(n1, n2, n3);	
	}else{
		t = sel(n1, n2, n3) != sel(n1, n2, n3);
	}
	return t;
}




/**
 * Hand over Hand remove.
 * 
 * */
void hhRemove(Set s, int in){
	if(in > LOW && in< HIGH){
		Node cur = s.head;
		if(?? && comp(cur, null, null)){ lock(sel(cur, null, null)); }
		Node prev = null;
		bit more = 1;
		for(int i=0; i<5; ++i){
			if(more && cur.val < in){
				anyorder{
					if(?? && comp(cur, prev, null)){ lock(sel(cur, prev, null)); }
					if(?? && comp(cur, prev, null)){ unlock(sel(cur, prev, null)); }
					{
						prev = cur;
						cur = cur.next;
					}	
				}
			}else{
				more = 0;	
			}
		}
		if(cur.val == in){
			prev.next = cur.next;			
		}
		if(?? && comp(cur, prev, null)){ unlock(sel(cur, prev, null)); }
		if(?? && comp(cur, prev, null)){ unlock(sel(cur, prev, null)); }
	}	
}



bit test(bit a, bit b){	
	return 1;
}



bit testSK(bit a, bit b) implements test{
	Set s = newSet();
	setAddSeq(s, 3);
	setAddSeq(s, 4);
	setAddSeq(s, 5);
	
	ploop(int i; 2){
		int t = 3;
		if(i==0 && a){ t = 4; }
		if(i==1 && b){ t = 5; }	
		hhRemove(s, t);
	}
	
	
	int[MAXSZ] rv = 0;
	rv = toArray(s);
	
	if(!a && !b){
		assert rv[1] == 4 && rv[2] == 5 && rv[3] == HIGH;
	}
	if(a && !b){
		assert rv[1] == 5 && rv[2] == HIGH;
	}
	if(!a && b){
		assert rv[1] == 4 && rv[2] == HIGH;
	}
	if(a && b){
		assert rv[1] == 3 && rv[2] == HIGH;
	}
		
	return 1;
}

