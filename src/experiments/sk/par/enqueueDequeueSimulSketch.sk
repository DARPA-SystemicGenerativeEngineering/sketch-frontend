struct Queue {
    Node tail;
    Node prevHead;
}

struct Node {
    int val;
    Node next;
    bit taken;
}

void enqueue (Queue q, int val) {
    Node n = new Node ();
    n.val = val;
    n.taken = 0;
    n.next = null;

    Node oldTail = null;
    // oldTail = AtomicSwap ({| q.tail|n |}, {| n|q.tail |});
    atomic {
        oldTail = ?? ? q.tail : n;
        if (??)  q.tail = n;
        else     n = q.tail;
    }
    oldTail.next = n;
}

int dequeue (Queue q) {
    Node tmp = null;
    int wasTaken = 1;

    for (int i = 0; wasTaken != 0; ++i) {
        anyorder {
            tmp = ?? ? q.prevHead :
                       (?? ? q.prevHead.next : q.prevHead.next.next);
            if (null == tmp)  return -1;

            q.prevHead = ?? ? tmp :
                              (?? ? tmp.next :
                                    (?? ? q.prevHead : q.prevHead.next));
            if (tmp.taken != 1) {
                // wasTaken = AtomicSwap (tmp.taken, 1);
                atomic {
                    wasTaken = tmp.taken;
                    tmp.taken = 1;
                }
            }
        }
    }

    return tmp.val;
}

bit alwaysTrue () {
    return 1;
}

bit verify (Queue q, int[2] popped) {
    Node next = q.prevHead;
    int taken = 1;
    int nfree = 0;

    assert q.prevHead.taken == 1;
    for (int i = 0; next != null; ++i) {
        if (0 == taken) {
            assert next.taken == 0;
            ++nfree;
        } else if (0 == next.taken) {
            taken = 0;
            nfree = 1;
        }
        next = next.next;
    }

    if (nfree == 0) {
        assert (popped[0] == 1 && popped[1] == 2)
               || (popped[0] == 2 && popped[1] == 1);
    } else if (nfree == 1) {
        assert (popped[0] == 1 && popped[1] == -1)
               || (popped[0] == -1 && popped[1] == 1)
               || (popped[0] == 2 && popped[1] == -1)
               || (popped[0] == -1 && popped[1] == 2);
    } else if (nfree == 2) {
        assert (popped[0] == -1 && popped[1] == -1);
    } else {
        assert 0;
    }

    return 1;
}

bit dequeueTest () implements alwaysTrue {
    Queue q = new Queue ();
    q.prevHead = new Node ();
    q.prevHead.val = -1;
    q.prevHead.taken = 1;
    q.prevHead.next = null;
    q.tail = q.prevHead;

    int[2] popped = 0;

    ploop (int i; 4) {
        if (0 == i%2)
            enqueue (q, i/2 + 1);
        else
            popped[i/2] = dequeue (q);
    }

    return verify (q, popped);
}
