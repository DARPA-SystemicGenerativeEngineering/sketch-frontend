struct Queue {
    Node tail;
    Node prevHead;
}

struct Node {
    int val;
    Node next;
    bit taken;
}

void enqueue (Queue q, int val) {
    Node n = new Node ();
    n.val = val;
    n.taken = 0;
    n.next = null;

    Node oldTail = null;
    // oldTail = AtomicSwap (q.tail, n);
    atomic {
        oldTail = q.tail;
        q.tail = n;
    }
    oldTail.next = n;
}

int dequeue (Queue q) {
    Node next = q.prevHead.next;
    int wasTaken = 0;

    for (int i = 0; (next != null && 1 == wasTaken); ++i) {
        // wasTaken = AtomicSwap (next.taken, 1)
        atomic {
            wasTaken = next.taken;
            next.taken = 1;
        }
        if (1 == wasTaken)  next = next.next;
    }

    if (null == next) return -1;

    int stored = next.val;
    for (int i = 0; (null != next && 1 == next.taken); ++i) {
        q.prevHead = next;
        next = next.next;
    }

    return stored;
}

bit alwaysTrue () {
    return 1;
}

bit verify (Queue q, int[2] popped) {
    Node next = q.prevHead;
    for (int i = 0; next != null; ++i) {
        assert next.taken == 1;
        next = next.next;
    }

    assert (popped[0] == 1 && popped[0] == 2)
           || (popped[0] == 2 && popped[1] == 1);

    return 1;
}

bit dequeueTest () implements alwaysTrue {
    Queue q = new Queue ();
    q.prevHead = new Node ();
    q.prevHead.val = -1;
    q.prevHead.taken = 1;
    q.prevHead.next = null;
    q.tail = q.prevHead;

    enqueue (q, 1);
    enqueue (q, 2);

    int[2] popped = 0;

    ploop (int i; 2) {
        popped[i] = dequeue (q);
    }

    return verify (q, popped);
}
