// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.13.2,
// (C) 2004-2007 Robert Grimm,
// on Tuesday, April 8, 2008 at 12:47:59 AM.
// Edit at your own risk.
// ===========================================================================

package streamit.frontend.parser;

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import java.util.List;

import streamit.frontend.nodes.ExprAlt;
import streamit.frontend.nodes.ExprChoiceBinary;
import streamit.frontend.nodes.ExprChoiceSelect;
import static streamit.frontend.nodes.ExprChoiceSelect.Select;
import static streamit.frontend.nodes.ExprChoiceSelect.Selector;
import static streamit.frontend.nodes.ExprChoiceSelect.SelectChain;
import static streamit.frontend.nodes.ExprChoiceSelect.SelectField;
import static streamit.frontend.nodes.ExprChoiceSelect.SelectOr;
import streamit.frontend.nodes.ExprChoiceUnary;
import streamit.frontend.nodes.ExprConstant;
import streamit.frontend.nodes.Expression;
import streamit.frontend.nodes.ExprParen;
import streamit.frontend.nodes.ExprStar;
import streamit.frontend.nodes.ExprTernary;
import streamit.frontend.nodes.ExprVar;
import streamit.frontend.nodes.FEContext;

/**
 * Packrat parser for grammar <code>streamit.frontend.parser.Regen</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.13.2, (C) 2004-2007 Robert Grimm.
 */
public final class Regen extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fExpr;
    Result fExpr$$Star1;
    Result fExprCond;
    Result fExprBin;
    Result fExprBin$$Star1;
    Result fExprPrefix;
    Result fExprPrefixNQ;
    Result fExprPrimary;
    Result fExprPrimary$$Star1;
    Result fTerm;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fInfixOp;
    Result fPrefixOp;
    Result fPostfixOp;
    Result fPostfixOpNQ;
    Result fSelector;
    Result fSelectorNQ;
    Result fIndex;
    Result fSelect;
    Result fSelChoice;
    Result fSelChoice$$Star1;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fSelChain;
    Result fSelChain$$Star1;
    Result fSel;
    Result fInOp;
    Result fPreOp;
    Result fPostOp;
    Result fs;
    Result fId;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class RegenColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Regen(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Regen(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new RegenColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Regen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pRegen(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pEOF(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpr(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpr)
      yyColumn.chunk1.fExpr = pExpr$1(yyStart);
    return yyColumn.chunk1.fExpr;
  }

  /** Actually parse streamit.frontend.parser.Regen.Expr. */
  private Result pExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprCond(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expression> l = yyResult.semanticValue();

        for (Expression e : l)  yyValue = new ExprAlt (yyValue, e);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal streamit.frontend.parser.Regen.Expr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpr$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpr$$Star1)
      yyColumn.chunk1.fExpr$$Star1 = pExpr$$Star1$1(yyStart);
    return yyColumn.chunk1.fExpr$$Star1;
  }

  /** Actually parse streamit.frontend.parser.Regen.Expr$$Star1. */
  private Result pExpr$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("|")) {

      yyResult = pExprCond(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression v$el$1 = yyResult.semanticValue();

        yyResult = pExpr$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Expression> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Expression>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprCond.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprCond(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprCond)
      yyColumn.chunk1.fExprCond = pExprCond$1(yyStart);
    return yyColumn.chunk1.fExprCond;
  }

  /** Actually parse streamit.frontend.parser.Regen.ExprCond. */
  private Result pExprCond$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprBin(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = ps(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("?")) {

        yyResult = pExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression b = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = ps(yyBase);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue(":")) {

            yyResult = pExprCond(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression c = yyResult.semanticValue();

              yyValue = new ExprTernary ("?:", a, b, c);

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("\":\" expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("\"?\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pExprBinNoQues(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expression a = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = ps(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("?")) {

        yyResult = pExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expression b = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = ps(yyBase);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue(":")) {

            yyResult = pExprCond(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expression c = yyResult.semanticValue();

              yyValue = new ExprTernary ("?:", a, b, c);

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("\":\" expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("\"?\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pExprBin(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprBin.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBin(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprBin)
      yyColumn.chunk1.fExprBin = pExprBin$1(yyStart);
    return yyColumn.chunk1.fExprBin;
  }

  /** Actually parse streamit.frontend.parser.Regen.ExprBin. */
  private Result pExprBin$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pExprBin$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Object> l = yyResult.semanticValue();

        yyValue = binExpr (yyValue, l.list ());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal
   * streamit.frontend.parser.Regen.ExprBin$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBin$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInfixOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BI ops = yyResult.semanticValue();

      yyResult = pExprPrefix(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression r = yyResult.semanticValue();

        yyValue = new P<BI,Expression>(ops, r);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal
   * streamit.frontend.parser.Regen.ExprBin$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBin$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprBin$$Star1)
      yyColumn.chunk1.fExprBin$$Star1 = pExprBin$$Star1$1(yyStart);
    return yyColumn.chunk1.fExprBin$$Star1;
  }

  /** Actually parse streamit.frontend.parser.Regen.ExprBin$$Star1. */
  private Result pExprBin$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Object> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprBin$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Object v$el$1 = yyResult.semanticValue();

      yyResult = pExprBin$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Object> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Object>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprBinNoQues.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBinNoQues(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<Object> yyRepValue1;
    Expression   yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pExprBinNoQues$$Choice1(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Object v$el$2 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Object>(v$el$2, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for l.
        Pair<Object> l = yyRepValue1.reverse();

        yyResult = pInfixOp(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BI ops = yyResult.semanticValue();

          yyResult = pExprPrefixNQ(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expression r = yyResult.semanticValue();

            yyValue = new ExprChoiceBinary (yyValue, ops.i, r);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for l.
    }

    // Alternative 2.

    yyResult = pExprPrefixNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal
   * streamit.frontend.parser.Regen.ExprBinNoQues$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprBinNoQues$$Choice1(final int yyStart)
    throws IOException {

    Result     yyResult;
    Result     yyPredResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInfixOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BI ops = yyResult.semanticValue();

      yyResult = pExprPrefix(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression r = yyResult.semanticValue();

        yyPredResult = pInfixOp(yyResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pExprPrefixNQ(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = new P<BI,Expression>(ops, r);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrefix(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprPrefix)
      yyColumn.chunk1.fExprPrefix = pExprPrefix$1(yyStart);
    return yyColumn.chunk1.fExprPrefix;
  }

  /** Actually parse streamit.frontend.parser.Regen.ExprPrefix. */
  private Result pExprPrefix$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrefixOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BI ops = yyResult.semanticValue();

      yyResult = pExprPrefix(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression e = yyResult.semanticValue();

        yyValue = new ExprChoiceUnary (ops.i, e);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pExprPostfix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprPrefixNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrefixNQ(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprPrefixNQ)
      yyColumn.chunk1.fExprPrefixNQ = pExprPrefixNQ$1(yyStart);
    return yyColumn.chunk1.fExprPrefixNQ;
  }

  /** Actually parse streamit.frontend.parser.Regen.ExprPrefixNQ. */
  private Result pExprPrefixNQ$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrefixOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BI ops = yyResult.semanticValue();

      yyResult = pExprPrefixNQ(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression e = yyResult.semanticValue();

        yyValue = new ExprChoiceUnary (ops.i, e);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pExprPostfixNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPostfix(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfixOp(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BI v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<BI>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI ops : l)  yyValue = new ExprChoiceUnary (ops.i, yyValue);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprPostfixNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPostfixNQ(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfixOp(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BI v$el$2 = yyResult.semanticValue();

          yyPredResult = pPostfixOpNQ(yyResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<BI>(v$el$2, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI ops : l)  yyValue = new ExprChoiceUnary (ops.i, yyValue);

        yyResult = pPostfixOpNQ(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BI ops = yyResult.semanticValue();

          yyValue = new ExprChoiceUnary (ops.i, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for l.
    }

    // Alternative 2.

    yyResult = pExprPrimaryNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrimary(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprPrimary)
      yyColumn.chunk1.fExprPrimary = pExprPrimary$1(yyStart);
    return yyColumn.chunk1.fExprPrimary;
  }

  /** Actually parse streamit.frontend.parser.Regen.ExprPrimary. */
  private Result pExprPrimary$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pExprPrimary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Selector> l = yyResult.semanticValue();

        for (Selector s : l)  yyValue = new ExprChoiceSelect (yyValue, s);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal
   * streamit.frontend.parser.Regen.ExprPrimary$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrimary$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExprPrimary$$Star1)
      yyColumn.chunk1.fExprPrimary$$Star1 = pExprPrimary$$Star1$1(yyStart);
    return yyColumn.chunk1.fExprPrimary$$Star1;
  }

  /** Actually parse streamit.frontend.parser.Regen.ExprPrimary$$Star1. */
  private Result pExprPrimary$$Star1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<Selector> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Selector v$el$1 = yyResult.semanticValue();

      yyResult = pExprPrimary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Selector> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Selector>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ExprPrimaryNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprPrimaryNQ(final int yyStart) throws IOException {
    Result         yyResult;
    Result         yyPredResult;
    int            yyRepetition1;
    Pair<Selector> yyRepValue1;
    Expression     yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSelector(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Selector v$el$1 = yyResult.semanticValue();

          yyPredResult = pSelectorNQ(yyResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Selector>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for l.
        Pair<Selector> l = yyRepValue1.reverse();

        yyResult = pSelectorNQ(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Selector ls = yyResult.semanticValue();

          for (Selector s : l)  yyValue = new ExprChoiceSelect (yyValue, s);
          yyValue = new ExprChoiceSelect (yyValue, ls);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for l.

      // Nested alternative 2.

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTerm)
      yyColumn.chunk1.fTerm = pTerm$1(yyStart);
    return yyColumn.chunk1.fTerm;
  }

  /** Actually parse streamit.frontend.parser.Regen.Term. */
  private Result pTerm$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pVar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("(")) {

      yyResult = pExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expression e = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue(")")) {

          yyValue = new ExprParen (e);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("term expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.InfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfixOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fInfixOp)
      yyColumn.chunk2.fInfixOp = pInfixOp$1(yyStart);
    return yyColumn.chunk2.fInfixOp;
  }

  /** Actually parse streamit.frontend.parser.Regen.InfixOp. */
  private Result pInfixOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("(")) {

      yyResult = pInOpChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("infix op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.InOpChoice.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInOpChoice(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("|")) {

          yyResult = pInOp(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            BI v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<BI>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("\"|\" expected", yyBase);
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI op : l)  yyValue.i |= op.i;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.PrefixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrefixOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPrefixOp)
      yyColumn.chunk2.fPrefixOp = pPrefixOp$1(yyStart);
    return yyColumn.chunk2.fPrefixOp;
  }

  /** Actually parse streamit.frontend.parser.Regen.PrefixOp. */
  private Result pPrefixOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = ps(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("?")) {

        yyValue = new BI (yyValue.i | ExprChoiceUnary.NONE);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("\"?\" expected", yyBase);
      }

      // Nested alternative 2.

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("(")) {

      yyResult = pPreOpChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue(")")) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase   = yyChoice1;
          yyResult = ps(yyBase);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue("?")) {

            yyValue = new BI (yyValue.i | ExprChoiceUnary.NONE);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("\"?\" expected", yyBase);
          }

          // Nested alternative 2.

          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("prefix op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.PreOpChoice.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreOpChoice(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("|")) {

          yyResult = pPreOp(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            BI v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<BI>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("\"|\" expected", yyBase);
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI op : l)  yyValue = new BI (yyValue.i | op.i);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.PostfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPostfixOp)
      yyColumn.chunk2.fPostfixOp = pPostfixOp$1(yyStart);
    return yyColumn.chunk2.fPostfixOp;
  }

  /** Actually parse streamit.frontend.parser.Regen.PostfixOp. */
  private Result pPostfixOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostfixOpNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = ps(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("?")) {

        yyValue = new BI (yyValue.i | ExprChoiceUnary.NONE);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("\"?\" expected", yyBase);
      }

      // Nested alternative 2.

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.PostfixOpNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixOpNQ(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPostfixOpNQ)
      yyColumn.chunk2.fPostfixOpNQ = pPostfixOpNQ$1(yyStart);
    return yyColumn.chunk2.fPostfixOpNQ;
  }

  /** Actually parse streamit.frontend.parser.Regen.PostfixOpNQ. */
  private Result pPostfixOpNQ$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("(")) {

      yyResult = pPostOpChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("postfix op n q expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.PostOpChoice.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostOpChoice(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<BI>   yyRepValue1;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPostOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("|")) {

          yyResult = pPostOp(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            BI v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<BI>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("\"|\" expected", yyBase);
        }
        break;
      }
      { // Start scope for l.
        Pair<BI> l = yyRepValue1.reverse();

        for (BI op : l)  yyValue = new BI (yyValue.i | op.i);;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for l.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Selector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelector(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSelector)
      yyColumn.chunk2.fSelector = pSelector$1(yyStart);
    return yyColumn.chunk2.fSelector;
  }

  /** Actually parse streamit.frontend.parser.Regen.Selector. */
  private Result pSelector$1(final int yyStart) throws IOException {
    Result     yyResult;
    Selector   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelect(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIndex(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.SelectorNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelectorNQ(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSelectorNQ)
      yyColumn.chunk2.fSelectorNQ = pSelectorNQ$1(yyStart);
    return yyColumn.chunk2.fSelectorNQ;
  }

  /** Actually parse streamit.frontend.parser.Regen.SelectorNQ. */
  private Result pSelectorNQ$1(final int yyStart) throws IOException {
    Result     yyResult;
    Selector   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelectNQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIndex(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Index.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIndex(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fIndex)
      yyColumn.chunk2.fIndex = pIndex$1(yyStart);
    return yyColumn.chunk2.fIndex;
  }

  /** Actually parse streamit.frontend.parser.Regen.Index. */
  private Result pIndex$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Selector   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("[")) {

      yyResult = pExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("]")) {

          if (true) { throw new RuntimeException ("NYI: array indices"); }

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\"]\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("index expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Select.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelect(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSelect)
      yyColumn.chunk2.fSelect = pSelect$1(yyStart);
    return yyColumn.chunk2.fSelect;
  }

  /** Actually parse streamit.frontend.parser.Regen.Select. */
  private Result pSelect$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSel(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("(")) {

      yyResult = pSelChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue(")")) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase   = yyChoice1;
          yyResult = ps(yyBase);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue("?")) {

            yyValue = Select.clone (yyValue);  yyValue.setOptional (true);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("\"?\" expected", yyBase);
          }

          // Nested alternative 2.

          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("select expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.SelectNQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelectNQ(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSel(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("(")) {

      yyResult = pSelChoice(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = ps(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("select n q expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.SelChoice.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelChoice(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSelChoice)
      yyColumn.chunk2.fSelChoice = pSelChoice$1(yyStart);
    return yyColumn.chunk2.fSelChoice;
  }

  /** Actually parse streamit.frontend.parser.Regen.SelChoice. */
  private Result pSelChoice$1(final int yyStart) throws IOException {
    Result     yyResult;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelChain(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSelChoice$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Select> l = yyResult.semanticValue();

        for (Select s : l)  yyValue = new SelectOr (yyValue, s);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal
   * streamit.frontend.parser.Regen.SelChoice$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelChoice$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSelChoice$$Star1)
      yyColumn.chunk2.fSelChoice$$Star1 = pSelChoice$$Star1$1(yyStart);
    return yyColumn.chunk2.fSelChoice$$Star1;
  }

  /** Actually parse streamit.frontend.parser.Regen.SelChoice$$Star1. */
  private Result pSelChoice$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Select> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("|")) {

      yyResult = pSelChain(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Select v$el$1 = yyResult.semanticValue();

        yyResult = pSelChoice$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Select> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Select>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.SelChain.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelChain(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSelChain)
      yyColumn.chunk3.fSelChain = pSelChain$1(yyStart);
    return yyColumn.chunk3.fSelChain;
  }

  /** Actually parse streamit.frontend.parser.Regen.SelChain. */
  private Result pSelChain$1(final int yyStart) throws IOException {
    Result     yyResult;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelect(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSelChain$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Select> l = yyResult.semanticValue();

        for (Select s : l)  yyValue = new SelectChain (yyValue, s);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal
   * streamit.frontend.parser.Regen.SelChain$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelChain$$Star1(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSelChain$$Star1)
      yyColumn.chunk3.fSelChain$$Star1 = pSelChain$$Star1$1(yyStart);
    return yyColumn.chunk3.fSelChain$$Star1;
  }

  /** Actually parse streamit.frontend.parser.Regen.SelChain$$Star1. */
  private Result pSelChain$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Select> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelect(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Select v$el$1 = yyResult.semanticValue();

      yyResult = pSelChain$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Select> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Select>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Sel.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSel(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSel) yyColumn.chunk3.fSel = pSel$1(yyStart);
    return yyColumn.chunk3.fSel;
  }

  /** Actually parse streamit.frontend.parser.Regen.Sel. */
  private Result pSel$1(final int yyStart) throws IOException {
    Result     yyResult;
    Select     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(".")) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String id = yyResult.semanticValue();

        yyValue = new SelectField (id);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("sel expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Var.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVar(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String id = yyResult.semanticValue();

      yyValue = new ExprVar (getCx (), id);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNum(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String n = yyResult.semanticValue();

      yyValue = ExprConstant.createConstant (getCx (), n);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("??")) {

      yyValue = new ExprStar (getCx ());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.InOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fInOp)
      yyColumn.chunk3.fInOp = pInOp$1(yyStart);
    return yyColumn.chunk3.fInOp;
  }

  /** Actually parse streamit.frontend.parser.Regen.InOp. */
  private Result pInOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("||")) {

      yyValue = new BI (ExprChoiceBinary.LOR);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("&&")) {

      yyValue = new BI (ExprChoiceBinary.LAND);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<<")) {

      yyValue = new BI (ExprChoiceBinary.LSHFT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(">>")) {

      yyValue = new BI (ExprChoiceBinary.RSHFT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("==")) {

      yyValue = new BI (ExprChoiceBinary.EQ);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("!=")) {

      yyValue = new BI (ExprChoiceBinary.NEQ);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<=")) {

      yyValue = new BI (ExprChoiceBinary.LTEQ);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(">=")) {

      yyValue = new BI (ExprChoiceBinary.GTEQ);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("\\|")) {

      yyValue = new BI (ExprChoiceBinary.BOR);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("^")) {

      yyValue = new BI (ExprChoiceBinary.BXOR);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("&")) {

      yyValue = new BI (ExprChoiceBinary.BAND);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 12.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<")) {

      yyValue = new BI (ExprChoiceBinary.LT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 13.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(">")) {

      yyValue = new BI (ExprChoiceBinary.GT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 14.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("+")) {

      yyValue = new BI (ExprChoiceBinary.ADD);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 15.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("-")) {

      yyValue = new BI (ExprChoiceBinary.SUB);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 16.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("*")) {

      yyValue = new BI (ExprChoiceBinary.MUL);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 17.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("/")) {

      yyValue = new BI (ExprChoiceBinary.DIV);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 18.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("%")) {

      yyValue = new BI (ExprChoiceBinary.MOD);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("in op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.PreOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPreOp)
      yyColumn.chunk3.fPreOp = pPreOp$1(yyStart);
    return yyColumn.chunk3.fPreOp;
  }

  /** Actually parse streamit.frontend.parser.Regen.PreOp. */
  private Result pPreOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("++")) {

      yyValue = new BI (ExprChoiceUnary.PREINC);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("--")) {

      yyValue = new BI (ExprChoiceUnary.PREDEC);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("+")) {

      yyValue = new BI (0);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("-")) {

      yyValue = new BI (ExprChoiceUnary.NEG);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("!")) {

      yyValue = new BI (ExprChoiceUnary.NOT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("~")) {

      yyValue = new BI (ExprChoiceUnary.BNOT);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("pre op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.PostOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostOp(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPostOp)
      yyColumn.chunk3.fPostOp = pPostOp$1(yyStart);
    return yyColumn.chunk3.fPostOp;
  }

  /** Actually parse streamit.frontend.parser.Regen.PostOp. */
  private Result pPostOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    BI         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("++")) {

      yyValue = new BI (ExprChoiceUnary.POSTINC);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("--")) {

      yyValue = new BI (ExprChoiceUnary.POSTDEC);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("post op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.WS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.EOF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOF(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOF expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.s.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ps(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fs) yyColumn.chunk3.fs = ps$1(yyStart);
    return yyColumn.chunk3.fs;
  }

  /** Actually parse streamit.frontend.parser.Regen.s. */
  private Result ps$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSYM(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.SYM.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSYM(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '?':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('?' == yyC) {

              yyValue = "??";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "?";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('+' == yyC) {

              yyValue = "++";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "+";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('-' == yyC) {

              yyValue = "--";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "-";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('|' == yyC) {

              yyValue = "||";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "|";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('&' == yyC) {

              yyValue = "&&";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "&";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '<':
              {
                yyValue = "<<";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '=':
              {
                yyValue = "<=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "<";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '>':
              {
                yyValue = ">>";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '=':
              {
                yyValue = ">=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = ">";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "==";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "!=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "!";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\\':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('|' == yyC) {

              yyValue = "\\|";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '^':
        {
          yyValue = "^";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '*':
        {
          yyValue = "*";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = "/";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '%':
        {
          yyValue = "%";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '~':
        {
          yyValue = "~";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = ":";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("SYM expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    RegenColumn yyColumn = (RegenColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fId) yyColumn.chunk3.fId = pId$1(yyStart);
    return yyColumn.chunk3.fId;
  }

  /** Actually parse streamit.frontend.parser.Regen.Id. */
  private Result pId$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.ID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pID(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if ((('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ID expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.Num.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNum(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNUM(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pWS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal streamit.frontend.parser.Regen.NUM.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNUM(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("NUM expected", yyStart);
    return yyError;
  }

  // =========================================================================

  // TODO: get the line/column from Rats!
  private FEContext cx;
  public void setCx (FEContext cx) {  this.cx = cx;  }
  private FEContext getCx ()       {  return cx;  }

  private static class P<T1,T2> {
    public T1 one;  public T2 two;
    public P (T1 one, T2 two) {
      this.one = one;  this.two = two;
    }
  }

  private static class BI {
    public int i;  public BI(){this(0);}  public BI(int i){this.i = i;}
  }

  private Expression binExpr (Expression e, List l) {
    for (Object o : l) {
      P<BI,Expression> p = (P<BI,Expression>) o;
      e = new ExprChoiceBinary (e, p.one.i, p.two);
    }
    return e;
  }

}
