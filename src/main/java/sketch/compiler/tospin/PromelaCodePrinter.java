/**
 *
 */
package streamit.frontend.tospin;

import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;

import streamit.frontend.nodes.ExprConstInt;
import streamit.frontend.nodes.ExprConstant;
import streamit.frontend.nodes.ExprFunCall;
import streamit.frontend.nodes.ExprVar;
import streamit.frontend.nodes.Expression;
import streamit.frontend.nodes.FEContext;
import streamit.frontend.nodes.FENode;
import streamit.frontend.nodes.FieldDecl;
import streamit.frontend.nodes.Function;
import streamit.frontend.nodes.Parameter;
import streamit.frontend.nodes.Statement;
import streamit.frontend.nodes.StmtAdd;
import streamit.frontend.nodes.StmtReorderBlock;
import streamit.frontend.nodes.StmtAssert;
import streamit.frontend.nodes.StmtAssign;
import streamit.frontend.nodes.StmtAtomicBlock;
import streamit.frontend.nodes.StmtBlock;
import streamit.frontend.nodes.StmtBody;
import streamit.frontend.nodes.StmtBreak;
import streamit.frontend.nodes.StmtContinue;
import streamit.frontend.nodes.StmtDoWhile;
import streamit.frontend.nodes.StmtEmpty;
import streamit.frontend.nodes.StmtEnqueue;
import streamit.frontend.nodes.StmtExpr;
import streamit.frontend.nodes.StmtFor;
import streamit.frontend.nodes.StmtIfThen;
import streamit.frontend.nodes.StmtJoin;
import streamit.frontend.nodes.StmtLoop;
import streamit.frontend.nodes.StmtFork;
import streamit.frontend.nodes.StmtPush;
import streamit.frontend.nodes.StmtReturn;
import streamit.frontend.nodes.StmtSendMessage;
import streamit.frontend.nodes.StmtSplit;
import streamit.frontend.nodes.StmtVarDecl;
import streamit.frontend.nodes.StmtWhile;
import streamit.frontend.nodes.StreamSpec;
import streamit.frontend.nodes.TempVarGen;
import streamit.frontend.nodes.Type;
import streamit.frontend.nodes.TypeArray;
import streamit.frontend.passes.CodePrinter;

/**
 * @author Chris Jones
 */
public class PromelaCodePrinter extends CodePrinter {
	protected boolean sawInit = false;
	protected TempVarGen vargen;
	protected String syncChan;

	public PromelaCodePrinter (TempVarGen vargen) {
		this (System.out, vargen);
	}

	public PromelaCodePrinter (OutputStream os, TempVarGen _vargen) {
		super (os);
		vargen = _vargen;
	}

	protected void printPrelude () {
		syncChan = vargen.nextVar ("_proc_sync_");

		printLine ("/**");
		printLine (" *------------------------------------------------------");
		printLine (" * Automatically generated by the SKETCH compiler.");
		printLine (" *------------------------------------------------------");
		printLine (" */");
		printLine ("#define null (-1)");
		printLine ("mtype = { done };");
		printLine ("chan "+ syncChan +" = [2] of { mtype };");
		printLine ("");
	}

	public Object visitStreamSpec (StreamSpec ss) {
		printPrelude ();

		// Declare the globals
		for (FENode n : (List<FieldDecl>) ss.getVars ())
			n.accept (this);
		printLine ("");

		for (Function f : (List<Function>) ss.getFuncs ()) {
			if (Function.FUNC_ASYNC == f.getCls ())
				emitProcess (f);
			else if (null != f.getSpecification ()) {
				f.assertTrue (!sawInit, "sorry, only one 'main()' function allowed");
				sawInit = true;
				emitInit (f);
			}
		}

		return null;
	}

	protected Object emitProcess (Function func) {
		func.assertTrue (null == func.getSpecification (),
						 "internal error: sketches should be gone");

		List<Parameter> params = func.getParams ();

		printLine ("proctype "
				+ func.getName ()
				+"(int __this"
				+ ((params.size () == 0) ? "" : ("; "+ paramsToString (params)))
				+ ")");
		printLine ("{");
		func.getBody ().accept (this);
		++indent; printLine (syncChan +" ! done;  /* return */"); --indent;
		printLine ("}");
		printLine ("");
		out.flush();

		return func;
	}

	protected Object emitInit (Function func) {
		printLine ("init");
		printLine ("{");

		++indent;
		// The params to "init()" should actually be locals to the function
		for (Parameter p : func.getParams ()) {
			printTab ();
			printLine (declToString (p.getType (), p.getName ()) + ";");
		}
		--indent;

		printIndentedStatement (func.getBody ());
		printLine ("}");
		printLine ("");
		out.flush();

		return func;
	}

	public Object visitExprFunCall (ExprFunCall call) {
		String params = "";
		for (Expression e : call.getParams ()) {
			if (0 < params.length ())
				params += ", ";
			params += e;
		}
		printLine ("run "+ call.getName () +" ("+ params +");");
		return null;
	}

	public Object visitFieldDecl (FieldDecl fd) {
		for (int i = 0; i < fd.getNumFields (); ++i)
			printVarDecl (fd.getType (i), fd.getName (i), fd.getInit (i));
		return null;
	}

	public Object visitStmtFor(StmtFor stmt)
	{
		List<Statement> newStmts =
			new ArrayList<Statement> (((StmtBlock) stmt.getBody ()).getStmts ());
		newStmts.add (stmt.getIncr ());
		StmtBlock newBody = new StmtBlock (stmt.getBody ().getCx (), newStmts);

		stmt.getInit ().accept (this);
		printLine ("do");
		printLine (":: !("+ stmt.getCond () +") -> break");
		printLine (":: else");
		newBody.accept (this);
		printLine ("od;");
		return stmt;
	}

	@Override
	public Object visitStmtIfThen(StmtIfThen stmt)
	{
		assertThreadLocal (stmt.getCond ());

		printLine ("if");
		printLine ("::"+ stmt.getCond () +" -> ");
		stmt.getCons ().accept (this);
		printLine (":: else");
		if (null != stmt.getAlt ()) {
			stmt.getAlt ().accept (this);
		} else {
			printTab (); printLine ("skip;");
		}
		printLine ("fi;");
		return stmt;
	}

	@Override
	public Object visitStmtWhile(StmtWhile stmt)
	{
		assertThreadLocal (stmt.getCond ());

		printLine ("do");
		printLine (":: !("+ stmt.getCond () +") -> break;");
		printLine (":: else");
    	stmt.getBody().accept (this);
    	printLine ("od;");
		return stmt;
	}

	@Override
	public Object visitStmtDoWhile(StmtDoWhile stmt)
	{
		assertThreadLocal (stmt.getCond ());

		FEContext cx = stmt.getCx ();
		String first = vargen.nextVar ("do_while_first_iter");
		List<Statement> newStmts =
			new ArrayList<Statement> (((StmtBlock) stmt.getBody ()).getStmts ());
		newStmts.add (new StmtAssign (cx, new ExprVar (cx, first),
									  ExprConstant.createConstant (cx, "0")));
		StmtBlock newBody = new StmtBlock (stmt.getBody ().getCx (), newStmts);

		printLine ("hidden bool "+ first +" = 1;");
		printLine ("do");
		printLine (":: !first && !("+ stmt.getCond () +") -> break;");
		printLine (":: else");
		newBody.accept (this);
		printLine ("od");

		return stmt;
	}

	@Override
	public Object visitStmtLoop(StmtLoop stmt)
	{
		return assertEliminated (stmt);
	}
	@Override
	public Object visitStmtFork(StmtFork stmt)
	{
		return assertEliminated (stmt);
		//return null;
	}

	@Override
	public Object visitStmtBlock(StmtBlock stmt)
	{
		printLine("{");
		indent++;
		super.visitStmtBlock(stmt);
		indent--;
		printLine("}");
		return stmt;
	}

	@Override
	public Object visitStmtAdd(StmtAdd stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtAssert(StmtAssert stmt)
	{
		printNumberedStmt (stmt);
		return super.visitStmtAssert(stmt);
	}

	@Override
	public Object visitStmtAssign(StmtAssign stmt)
	{
		printNumberedStmt (stmt);
		return super.visitStmtAssign(stmt);
	}

	@Override
	public Object visitStmtBody(StmtBody stmt)
	{
		printLine(stmt.toString());
		return super.visitStmtBody(stmt);
	}

	@Override
	public Object visitStmtBreak(StmtBreak stmt)
	{
		printNumberedStmt (stmt);
		return super.visitStmtBreak(stmt);
	}

	@Override
	public Object visitStmtContinue(StmtContinue stmt)
	{
		printNumberedStmt (stmt);
		return super.visitStmtContinue(stmt);
	}

	@Override
	public Object visitStmtEmpty(StmtEmpty stmt)
	{
		//printLine(stmt.toString());
		return super.visitStmtEmpty(stmt);
	}

	@Override
	public Object visitStmtEnqueue(StmtEnqueue stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtExpr(StmtExpr stmt)
	{
		printStmtNumber (stmt);
		Expression expr = stmt.getExpression ();
		if (expr instanceof ExprFunCall)
			expr.accept (this);
		else if (!(expr instanceof ExprConstInt))
			printLine(stmt.toString());
		return null;
	}

	@Override
	public Object visitStmtJoin(StmtJoin stmt)
	{
		printLine (syncChan +" ? done;  /* join */");
		return null;
	}

	@Override
	public Object visitStmtPush(StmtPush stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtReturn(StmtReturn stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtSendMessage(StmtSendMessage stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtSplit(StmtSplit stmt)
	{
		return assertEliminated (stmt);
	}

	@Override
	public Object visitStmtVarDecl(StmtVarDecl stmt)
	{
		for (int i = 0; i < stmt.getNumVars (); ++i)
			printVarDecl (stmt.getType (i), stmt.getName (i), stmt.getInit (i));
		return null;
	}

	public Object visitStmtReorderBlock(StmtReorderBlock block){
		return assertEliminated (block);
	}

	public Object visitStmtAtomicBlock(StmtAtomicBlock block){
		printStmtNumber (block);
		printLine("atomic");
		visitStmtBlock (block);
		return block;
	}

	/* === HELPER METHODS === */

	protected String declToString (Type t, String name) {
		if (t.isArray ()) {
			TypeArray ta = (TypeArray) t;
			return ta.getBase () +" "+ name +"["+ ta.getLength () +"]";
		} else
			return t +" "+ name;
	}

	protected String paramsToString (List<Parameter> params) {
		String pms = "";
		for (Parameter p : params) {
			if (pms.length () > 0)
				pms += "; ";
			pms += declToString (p.getType (), p.getName ());
		}
		return pms;
	}

	protected void printVarDecl (Type t, String name, Expression init) {
		String decl = declToString (t, name);

		printLine (decl +";");
		if (null != init)
			printLine (name +" = "+ init +";");
	}

	protected void printNumberedStmt (Statement stmt) {
		printStmtNumber (stmt);
		printLine(stmt.toString() +";");
	}

	protected void printStmtNumber (Statement stmt) {
		stmt.assertTrue (null != stmt.getTag (), "Unnumbered statement: "+ stmt);

		printLine ("_ = "+ stmt.getTag ()+ ";");
	}

	/**
	 * Assert that this statement is thread local; namely, a constant
	 * or read from a local variable (register).
	 */
	protected void assertThreadLocal (Expression e) {
		// TODO: if e isn't constant, we should ensure that it's actually a
		// a local variable.
		e.assertTrue (e.isConstant () || (e instanceof ExprVar),
					  "Non-local expression in condition: "+ e);
	}

	protected Object assertEliminated (FENode node) {
		node.assertTrue (false, "internal error; I should have been eliminated.");
		return null;
	}
}
