//@Description Sketch to reverse a list.
pragma options "--unrollamnt 4";
int N = 4;

struct node{
    node next;
    bit val;    
}

struct list{
    node head;  
    node tail;
}

list newList(){
    list l = new list();
    l.head = null;
    l.tail = null;
    return l;
}

node newNode(){
    node t = new node();
    t.next = null;
    t.val = 0;
    return t;
}



generator node hole(list l1, list l2){  
    return {| null | ( (l1 | l2)(.head | .tail) )(.next)?  |}   ;
}

generator node holeB(list l1, list l2, node n){
    return  (?? ? hole(l1, l2) : n); 
}


generator bit cond(list l1, list l2, node tmp){ 
    node n1 = holeB(l1, l2, tmp);
    node n2 = holeB(l1, l2, tmp);
    return {| ?? | n1 (== | !=) n2   |};
}

list reverseSK(list l){
    list nl = newList();        
    node tmp = null;    
    bit c  = cond(l, nl, tmp);
    while(c){
        if(cond(l, nl, tmp)){ {| ( tmp | (l | nl)(.head | .tail) ) (.next)? |}   = holeB(l, nl, tmp);}// 83 * 10 * 6 = 4980
        repeat(??){
                if(cond(l, nl, tmp)){ {| ( tmp | (l | nl)(.head | .tail) ) (.next)? |}    = holeB(l, nl, tmp);}// 83 * 10 * 6 = 4980
        }
        c  = cond(l, nl, tmp);
    }   
    return nl;
}


void popList(int n, list l, ref node[N] nodes){
    for(int i=0; i<n;++i){
        node t = newNode();
        if(i>0){
            l.tail.next = t;
        }
        l.tail = t;
        nodes[i] = t; 
    } 
    l.head = nodes[0];
}

 
void check(int n, list l, node[N] nodes){
    node cur = l.head;
    int i=0;
    while(cur != null){
        assert cur == nodes[n-1-i];
        cur = cur.next;     
        i = i+1;
    }
    assert i == n;
    if(n > 0){
        assert l.head == nodes[n-1];
        assert l.tail == nodes[0];
        assert l.tail.next == null;
    }else{
        assert l.head == null;
        assert l.tail == null;
    }
}

harness void main(int n){
    if(n >= N){ n = N-1; }
    node[N] nodes = null;
    list l = newList();
    
    popList(n, l, nodes);   
    
    l = reverseSK(l);
    
    if(n>0){ assert l.tail.next == null; }
    
    check(n, l, nodes);
    
}