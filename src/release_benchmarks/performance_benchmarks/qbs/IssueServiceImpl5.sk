pragma options "--bnd-unroll-amnt 10 --bnd-inbits 2 --beopt:simiters 10";
#define MAX_LEN 4

struct Issue
{
 int id;
}

Issue Issue_new (int id)
{
  Issue n = new Issue();
  n.id = id;
  return n;
}


harness void getOpenIssueCountByProjectId(int projectId, int issues_sz, int ret,
                                          int [MAX_LEN]  issues_id)

 {
 Issue [MAX_LEN]  issues;
 for (int i = 0; i < MAX_LEN; ++i) {
  issues[i] = new Issue();
  issues[i].id = issues_id[i]; }
 
 if (true && (issues_sz >= 0 && issues_sz < MAX_LEN))
  {
  if (true)
   {
   assert postcondition(projectId, issues_sz, issues_sz, issues); }
   }
  }


bit postcondition(int projectId, int issues_sz, int ret, Issue [MAX_LEN]  issues) {
 Issue [MAX_LEN]  list1;
 int list1_sz;
 top_list1(issues, issues_sz, projectId, issues_sz, ret, issues, list1, list1_sz);
 Issue [MAX_LEN]  list2;
 int list2_sz;
 select_list2(list1, list1_sz, projectId, issues_sz, ret, issues, list2, list2_sz);
 return {| 
 ret == agg_agg3(list2, list2_sz) |}; }


void top_list1 (Issue [MAX_LEN] issues, int issues_sz, int projectId, int issues_sz, int ret, Issue [MAX_LEN] issues, ref Issue [MAX_LEN] list1, ref int list1_sz)
{
  list1_sz = {| projectId | issues_sz | ret |};
  list1 = issues[0::list1_sz];
}


void select_list2 (Issue [MAX_LEN] list1, int list1_sz, int projectId, int issues_sz, int ret, Issue [MAX_LEN] issues, ref Issue [MAX_LEN] list2, ref int list2_sz)
{
  list2_sz = 0;
  for (int i = 0; i < list1_sz; ++i)
  {
    if (select_list2_pred(list1[i], projectId, issues_sz, ret, issues))
    {
      list2[list2_sz] = list1[i];
      ++list2_sz;
    }
  }
}
generator bit select_list2_pred (Issue tuple, int projectId, int issues_sz, int ret, Issue [MAX_LEN] issues)
{
  if (tuple == null) return 0;
  else
  {
    bit out = 1;
    repeat (2)
    {
      bit pred0;
      int operator0 = ??;
      if (operator0 == 0) pred0 = 1;
      else if (operator0 == 1) pred0 = tuple.id > ??(2);
      else if (operator0 == 2) pred0 = tuple.id <= ??(2);
      else if (operator0 == 3) pred0 = tuple.id < ??(2);
      else if (operator0 == 4) pred0 = tuple.id == ??(2);
      else if (operator0 == 5) pred0 = tuple.id == projectId;
      else if (operator0 == 6) pred0 = tuple.id == ret;
      else pred0 = tuple.id >= ??(2);
      out = out && {| pred0 |};
    }
    return out;
  }
}


int agg_agg3 (Issue [MAX_LEN] list2, int list2_sz)
{
  int count = list2_sz;
  int max_id = 0; int sum_id = 0; int min_id = 3; int avg_id = 0;
  for (int i = 0; i < list2_sz; ++i)
  {
    if (list2[i].id > max_id)
      max_id = list2[i].id;
    if (list2[i].id < min_id)
      min_id = list2[i].id;
    sum_id += list2[i].id;
  }
  sum_id = count==0?0: (sum_id / count);  
  return {| count | max_id | sum_id | min_id | avg_id |};
}

