pragma options "--bnd-unroll-amnt 10 --bnd-inbits 2 --beopt:simiters 10";
#define MAX_LEN 4

struct User
{
 int status;
}

User User_new (int status)
{
  User n = new User();
  n.status = status;
  return n;
}


harness void getNumUsers(int users_sz, int ret, int [MAX_LEN]  users_status)

 {
 User [MAX_LEN]  users;
 for (int i = 0; i < MAX_LEN; ++i) {
  users[i] = new User();
  users[i].status = users_status[i]; }
 
 if (true && (users_sz >= 0 && users_sz < MAX_LEN))
  {
  if (true)
   {
   assert postcondition(users_sz, users_sz, users); }
   }
  }


bit postcondition(int users_sz, int ret, User [MAX_LEN]  users) {
 User [MAX_LEN]  list1;
 int list1_sz;
 top_list1(users, users_sz, users_sz, ret, users, list1, list1_sz);
 User [MAX_LEN]  list2;
 int list2_sz;
 select_list2(list1, list1_sz, users_sz, ret, users, list2, list2_sz);
 return {| 
 ret == agg_agg3(list2, list2_sz) |}; }


void top_list1 (User [MAX_LEN] users, int users_sz, int users_sz, int ret, User [MAX_LEN] users, ref User [MAX_LEN] list1, ref int list1_sz)
{
  list1_sz = {| users_sz | ret |};
  list1 = users[0::list1_sz];
}


void select_list2 (User [MAX_LEN] list1, int list1_sz, int users_sz, int ret, User [MAX_LEN] users, ref User [MAX_LEN] list2, ref int list2_sz)
{
  list2_sz = 0;
  for (int i = 0; i < list1_sz; ++i)
  {
    if (select_list2_pred(list1[i], users_sz, ret, users))
    {
      list2[list2_sz] = list1[i];
      ++list2_sz;
    }
  }
}
generator bit select_list2_pred (User tuple, int users_sz, int ret, User [MAX_LEN] users)
{
  if (tuple == null) return 0;
  else
  {
    bit out = 1;
    repeat (2)
    {
      bit pred0;
      int operator0 = ??;
      if (operator0 == 0) pred0 = 1;
      else if (operator0 == 1) pred0 = tuple.status > ??(2);
      else if (operator0 == 2) pred0 = tuple.status <= ??(2);
      else if (operator0 == 3) pred0 = tuple.status < ??(2);
      else if (operator0 == 4) pred0 = tuple.status == ??(2);
      else if (operator0 == 5) pred0 = tuple.status == ret;
      else pred0 = tuple.status >= ??(2);
      out = out && {| pred0 |};
    }
    return out;
  }
}


int agg_agg3 (User [MAX_LEN] list2, int list2_sz)
{
  int count = list2_sz;
  int max_status = 0; int sum_status = 0; int min_status = 3; int avg_status = 0;
  for (int i = 0; i < list2_sz; ++i)
  {
    if (list2[i].status > max_status)
      max_status = list2[i].status;
    if (list2[i].status < min_status)
      min_status = list2[i].status;
    sum_status += list2[i].status;
  }
  avg_status = count==0?0: (sum_status / count);
  return {| count | max_status | sum_status | min_status | avg_status |};
}

