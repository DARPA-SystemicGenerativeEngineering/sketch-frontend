int C=5;
int nchanges = 0;
bit choiceBaseCase0 = 0;
void calculateChanges(){
if(choiceBaseCase0) nchanges = nchanges + 1;
assert nchanges <= C;
}
void fuzzBaseCase0(ref bit x){
if(??) {choiceBaseCase0 = 1;
x = 1;
}
else x = 0;
}


MultiType evaluate_poly(MultiType poly,MultiType x){
}

MultiType compute_deriv(MultiType poly){
bit addBaseCase0;
fuzzBaseCase0(addBaseCase0);
if(addBaseCase0) {if (poly.lst.len <= 1) return new MultiType(flag = LIST, lst = new MTList(len = 1, listValues = {new MultiType(val =0, flag = INTEGER)}));}
}

MultiType compute_root(MultiType poly,MultiType x_0,MultiType epsilon){
}


MultiType compute_deriv_teacher(MultiType poly){
if((applyCompOp(len(poly), new MultiType(val=1,flag=INTEGER), LTE_COMP))){
return new MultiType(lst=new MTList(len=1, listValues={new MultiType(val=0,flag=INTEGER)}), flag=LIST);
}
MultiType result;
assignMT(result, new MultiType(lst=new MTList(len=0, listValues={}), flag=LIST));
void body0(MultiType i){
assignMT(result, applyBinOp(result, new MultiType(lst=new MTList(len=1, listValues={applyBinOp((i), (subscriptMTi(poly, i)), MUL_OP)}), flag=LIST), ADD_OP));
}
foreach(body0, range2(new MultiType(val=1,flag=INTEGER), len(poly)));
return result;
}


int INTEGER = 0;
int LIST = 1;
int STRING = 2;


int ADD_OP = 0;
int SUB_OP = 1;
int MUL_OP = 2;
int DIV_OP = 3;
int POW_OP = 4;
int MOD_OP = 5;

int USub = 0;
int UAdd = 1;
int UNot = 2;
int UInvert = 3;

int EQ_COMP = 0;
int NEQ_COMP = 1;
int LT_COMP = 2;
int LTE_COMP = 3;
int GT_COMP = 4;
int GTE_COMP = 5;

MultiType intTypeMT = new MultiType(val = 0, flag = INTEGER);
MultiType listTypeMT = new MultiType(flag = LIST, lst = new MTList(len = 0, listValues={}));
MultiType noneMT = new MultiType(val =0, flag = INTEGER);


struct MultiType{
  int val;
  int flag;
  MTList lst;
  MTDict dict;
}

  struct MTDict{
    KeyValuePair[len] kvpairs;
    int len;
  }

    struct KeyValuePair{
      MultiType Key;
      MultiType Value;
    }

struct MTList{
  int len;
  MultiType[len] listValues;
}

void foreach(fun body, MultiType lst){
  assert lst.flag == LIST;
  MTList ma = lst.lst;
  for(int i101=0; i101<ma.len; i101++){
    body(ma.listValues[i101]);
  }
}

MultiType range1(MultiType x){
  assert x.flag == INTEGER;
  int ub = x.val;
  MultiType[ub] A;
  for(int i=0; i<ub; ++i){
    A[i] = new MultiType(val=i, flag=INTEGER);
  }
  MultiType m = new MultiType(lst=new MTList(listValues=A, len=ub), flag=LIST);
  return m;
}

MultiType range2(MultiType x, MultiType y){
  assert x.flag == INTEGER;
  assert y.flag == INTEGER;
  int lb = x.val;
  int ub = y.val;
  int newLen = ub - lb;
  MultiType[newLen] A;
  for(int i=lb; i< ub; ++i){
    A[i-lb] = new MultiType(val=i, flag=INTEGER);
  }
  MultiType m = new MultiType(lst=new MTList(listValues=A, len=newLen), flag=LIST);
  return m;
}

MultiType range3(MultiType x, MultiType y, MultiType step){
  assert x.flag == INTEGER;
  assert y.flag == INTEGER;
  assert step.flag == INTEGER;
  int lb = x.val;
  int ub = y.val;
  int stepdiff = step.val;
  int newLen = 0;
  for(int i=lb; i<ub-lb; i=i+stepdiff)
    newLen = newLen + 1;
  int newLen1 = newLen;
  MultiType[newLen1] A;
  int count = 0;
  for(int i=lb; i< ub-lb; i=i+stepdiff){
    A[count] = new MultiType(val=i, flag=INTEGER);
    count = count + 1;
  }
  MultiType m = new MultiType(lst=new MTList(listValues=A, len=newLen), flag=LIST);
  return m;
}

MultiType len(MultiType x){
    assert x.flag == LIST;
    return new MultiType(val = x.lst.len, flag=INTEGER);
}


// x[i]
MultiType subscriptMTi(MultiType list, MultiType index){
  assert list.flag == LIST;
  assert index.flag == INTEGER;
  assert index.val < list.lst.len;
  return list.lst.listValues[index.val];
}

// x[:]
MultiType subscriptMT(MultiType list, MultiType index){
  assert list.flag == LIST;
  assert index.flag == INTEGER;
  return list;
}

// x[:4]
MultiType subscriptMTu(MultiType list, MultiType rightIndex){
  assert list.flag == LIST;
  assert rightIndex.flag == INTEGER;
  return new MultiType(lst= new MTList(listValues = list.lst.listValues[0:rightIndex.val], len=rightIndex.val), flag = LIST);
}


// x[1:]
MultiType subscriptMTl(MultiType list, MultiType leftIndex){
  assert list.flag == LIST;
  assert leftIndex.flag == INTEGER;
  assert leftIndex.val < list.lst.len;
  int newLen = list.lst.len - leftIndex.val;
  MultiType[newLen] newListValues;
  for(int i=leftIndex.val; i < list.lst.len; i++)
    newListValues[i-leftIndex.val] = list.lst.listValues[i];
  return new MultiType(lst= new MTList(listValues=newListValues, len=newLen), flag = LIST);
}

// x[i:j]
MultiType subscriptMTul(MultiType list, MultiType leftIndex, MultiType rightIndex){
  assert list.flag == LIST;
  assert leftIndex.flag == INTEGER;
  assert rightIndex.flag == INTEGER;
  int newLen = rightIndex.val - leftIndex.val;
  MultiType[newLen] newListValues;
  for(int i=leftIndex.val; i < rightIndex.val; i++)
    newListValues[i-leftIndex.val] = list.lst.listValues[i];
  return new MultiType(lst= new MTList(listValues=newListValues, len=newLen), flag = LIST);
}


// x < y, applyCompOp(x,y, LT_COMP)

bit applyCompOp(MultiType left, MultiType right, int compop){
  if(left.flag != right.flag) return 0;
  if(compop == EQ_COMP)
    return applyEQCompOp(left,right);
  else if(compop == NEQ_COMP)
    return applyNEQCompOp(left,right);
  else if(compop == LT_COMP)
    return applyLTCompOp(left,right);
  else if(compop == LTE_COMP)
    return applyLTECompOp(left,right);
  else if(compop == GT_COMP)
    return applyGTCompOp(left,right);
  else if(compop == GTE_COMP)
    return applyGTECompOp(left,right);
}


//-x, not y

MultiType applyUnaryOp(MultiType operand, int op){
  if(op == USub) return applyUnarySubOp(operand);
  else if(op == UAdd) return applyUnaryAddOp(operand);
  else if(op == UNot) return applyUnaryNotOp(operand);
}

MultiType applyUnarySubOp(MultiType operand){
  assert operand.flag == INTEGER;
  return new MultiType(flag = INTEGER, val = -operand.val);
}

MultiType applyUnaryAddOp(MultiType operand){
  assert operand.flag == INTEGER;
  return operand;
}



// x + y, x -y

MultiType applyBinOp(MultiType left, MultiType right, int op){
  if(op == ADD_OP) return applyAddBinOp(left, right);
  else if(op == SUB_OP) return applySubBinOp(left,right);
  else if(op == MUL_OP) return applyMulBinOp(left,right);
  else if(op == DIV_OP) return applyDivBinOp(left,right);
  else if(op == POW_OP) return applyPowBinOp(left,right);
  else if(op == MOD_OP) return applyModBinOp(left,right);
 
}



MultiType applyAddBinOp(MultiType left, MultiType right){
    assert left.flag == right.flag; // can add same types only
    if(left.flag == INTEGER){
      return new MultiType(val = (left.val + right.val), flag = INTEGER);
    }
    else if(left.flag == LIST){
      int newLen = left.lst.len + right.lst.len;
      MultiType[newLen] newListValues = left.lst.listValues;
      for(int i=0; i<right.lst.len; i++)
	newListValues[i+left.lst.len] = right.lst.listValues[i];
      return new MultiType(flag=LIST,lst = new MTList(len = newLen, listValues = newListValues));
    }
}


MultiType applySubBinOp(MultiType left, MultiType right){
    assert left.flag == INTEGER; // python supports subtraction for only integers and floats
    assert right.flag == INTEGER;
    return new MultiType(val = left.val - right.val, flag = INTEGER);
}

MultiType applyMulBinOp(MultiType left, MultiType right){
  if(left.flag == INTEGER && right.flag == INTEGER) return applyMulBinOpInt(left, right);
  if(left.flag == LIST && right.flag == INTEGER) return applyMulBinOpList(left, right);
  if(left.flag == INTEGER && right.flag == LIST) return applyMulBinOpList(right, left);
  assert false;
}

MultiType applyMulBinOpInt(MultiType left, MultiType right){
    return new MultiType(val=intMul(left.val, right.val), flag = INTEGER);
}

MultiType applyMulBinOpList(MultiType left, MultiType right){
  if(right.val == 0) return new MultiType(flag = LIST, lst=new MTList(len = 0, listValues={}));
  int newLen = left.lst.len * right.val;
  MultiType[newLen] newListValues;
  int count = 0;
  for(int i = 0; i< newLen; i++){
    newListValues[i] = left.lst.listValues[count];
    count = count + 1;
    if(count == left.lst.len) count = 0;
  }
  return new MultiType(flag = LIST, lst = new MTList(len = newLen, listValues = newListValues));
}


MultiType applyDivBinOp(MultiType left, MultiType right){
  assert left.flag == INTEGER; // python supports division for only integers and floats
  assert right.flag == INTEGER;
  return new MultiType(val = intDiv(left.val,right.val), flag = INTEGER);
}

MultiType applyPowBinOp(MultiType left, MultiType right){
  assert left.flag == INTEGER; // python supports division for only integers and floats
  assert right.flag == INTEGER;
  return new MultiType(val = intPow(left.val,right.val), flag = INTEGER);
}

MultiType applyModBinOp(MultiType left, MultiType right){
  assert left.flag == INTEGER; // python supports division for only integers and floats
  assert right.flag == INTEGER;
  return new MultiType(val = intMod(left.val,right.val), flag = INTEGER);
}


bit applyEQCompOp(MultiType left, MultiType right){
  if (left.flag != right.flag) return 0;
  if(left.flag == LIST) return applyEQCompOpList(left, right);
  if(left.flag == INTEGER) return applyEQCompOpInt(left,right);
  return 0;
}

bit applyEQCompOpList(MultiType left, MultiType right){
  if(left.lst.len != right.lst.len) return 0;
  for(int i =0; i<left.lst.len; i++)
    if(!applyEQCompOpInt(left.lst.listValues[i], right.lst.listValues[i])) return 0;
  return 1;
}

bit applyEQCompOpInt(MultiType left, MultiType right){
  return left.val == right.val;
}

bit applyNEQCompOp(MultiType left, MultiType right){
  return !applyEQCompOp(left,right);
}


bit applyLTCompOp(MultiType left, MultiType right){
  if(left.flag == LIST) return applyLTCompOpList(left, right);
  if(left.flag == INTEGER) return applyLTCompOpInt(left,right);
  return 0;
}

bit applyLTCompOpList(MultiType left, MultiType right){
  for(int i =0; i<min(right.lst.len,left.lst.len); i++)
    if(!applyLTCompOpInt(left.lst.listValues[i], right.lst.listValues[i])) return 0;
  return 1;
}

bit applyLTCompOpInt(MultiType left, MultiType right){
  return left.val < right.val;
}

bit applyLTECompOp(MultiType left, MultiType right){
  if(left.flag == LIST) return applyLTECompOpList(left, right);
  if(left.flag == INTEGER) return applyLTECompOpInt(left,right);
  return 0;
}

bit applyLTECompOpList(MultiType left, MultiType right){
  for(int i =0; i<min(right.lst.len,left.lst.len); i++)
    if(!applyLTECompOpInt(left.lst.listValues[i], right.lst.listValues[i])) return 0;
  return 1;
}

bit applyLTECompOpInt(MultiType left, MultiType right){
  return left.val <= right.val;
}


bit applyGTCompOp(MultiType left, MultiType right){
  return !applyLTECompOp(left,right);
}

bit applyGTECompOp(MultiType left, MultiType right){
  return !applyLTCompOp(left,right);
}

bit setTrue(){
  return 1;
}

bit setFalse(){
  return 0;
}

MultiType incrementOne(MultiType x){
  assert x.flag == INTEGER;
  //x.val = x.val + 1;
  //return x;
  return new MultiType(val=x.val+1, flag = INTEGER);
}

MultiType incrementTwo(MultiType x){
  assert x.flag == INTEGER;
  //x.val = x.val + 2;
  //return x;
  return new MultiType(val=x.val+2, flag = INTEGER);
}

MultiType decrementOne(MultiType x){
  assert x.flag == INTEGER;
  //x.val = x.val - 1;
  //return x;
  return new MultiType(val=x.val-1, flag = INTEGER);
}

MultiType decrementTwo(MultiType x){
  assert x.flag == INTEGER;
  //x.val = x.val - 2;
  //return x;
  return new MultiType(val=x.val-2, flag = INTEGER);
}

MultiType setOne(MultiType x){
  assert x.flag == INTEGER;
  //x.val = 1;
  //return x;
  return new MultiType(val=1, flag = INTEGER);
}

MultiType setZero(MultiType x){
  assert x.flag == INTEGER;
  //x.val = 0;
  //return x;
  return new MultiType(val=0, flag = INTEGER);
}


int intMul(int x, int y){
  if(x>y) return intMul1(x,y);
  else return intMul1(y,x);
  //  return (x*y);
}

int intMul1(int x, int y);
int intDiv(int x, int y);
int intPow(int x, int y);
int intMod(int x, int y){
  return x%y;
}

void assignMT(ref MultiType lhs, MultiType rhs){
  lhs = rhs;
}

void assignMTArray(MultiType arrayName, MultiType index, MultiType rhs){
  assert arrayName.flag == LIST;
  assert index.flag == INTEGER;
  assert index.val < arrayName.lst.len;
  arrayName.lst.listValues[index.val] = rhs;
}

MultiType abs(MultiType x){
  assert x.flag == INTEGER;
  if(x.val < 0) x.val = -x.val;
  return x;
}


MultiType popList(ref MultiType left, MultiType index){
  MultiType result;
  assert left.flag == LIST;
  assert index.flag == INTEGER;
  assert left.lst.len > 0;
  int prevLen = left.lst.len;
  int removeIndex;
  if(index.val >= 0) removeIndex = index.val;
  else removeIndex = left.lst.len + index.val;
  
  assert removeIndex < left.lst.len && removeIndex >= 0;
  int newLen = left.lst.len-1;
  MultiType[newLen] newListValues;
  result = left.lst.listValues[removeIndex];  
  int count = 0;
  for(int i=0; i<left.lst.len; i++){
    if(i != removeIndex){
      newListValues[count] = left.lst.listValues[i];
      count = count + 1;
    }

  }
  left = new MultiType(flag = LIST, lst = new MTList(len = newLen, listValues=newListValues));
  return result;
}

void appendList(ref MultiType left, MultiType right){
    assert left.flag == LIST; // can append to list only
    int newLen = left.lst.len + 1;
    MultiType[newLen] newListValues;
    for(int i=0; i<left.lst.len; i++)
      newListValues[i] = left.lst.listValues[i];
    newListValues[left.lst.len] = right;
    left = new MultiType(flag=LIST,lst = new MTList(len = newLen, listValues = newListValues));

}

void extendList(ref MultiType left, MultiType right){
    assert left.flag == LIST;
    assert right.flag == LIST;
    int newLen = left.lst.len + right.lst.len;
    MultiType[newLen] newListValues = left.lst.listValues;
    for(int i=0; i<right.lst.len; i++)
      newListValues[i+left.lst.len] = right.lst.listValues[i];
    left = new MultiType(flag=LIST,lst = new MTList(len = newLen, listValues = newListValues));
}

void insertList(ref MultiType left, MultiType index, MultiType right){
  assert left.flag == LIST;
  assert index.flag == INTEGER;
  int newLen = left.lst.len + 1;
  MultiType[newLen] newListValues;
  int midIndex = min(left.lst.len, index.val);
  for(int i=0; i<midIndex; i++)
    newListValues[i] = left.lst.listValues[i];
  newListValues[midIndex] = right;
  for(int i=midIndex+1; i<left.lst.len; i++)
    newListValues[i] = left.lst.listValues[i-1];
  left = new MultiType(flag = LIST, lst = new MTList(len = newLen, listValues=newListValues));
}

MultiType indexList(ref MultiType left, MultiType value){
  MultiType result;
  assert left.flag == LIST;
  for(int i=0; i<left.lst.len; i++){
    if(applyEQCompOp(left.lst.listValues[i], value))
      return new MultiType(val = i, flag = INTEGER);
  }
  assert false;
}

void removeList(ref MultiType left, MultiType value){
  MultiType result;
  assert left.flag == LIST;
  assert left.lst.len > 0;
  int newLen = left.lst.len - 1;
  MultiType[newLen] newListValues;
  bit found = 0;
  int count = 0;
  for(int i=0; i<left.lst.len; i++){
    if(found == 0 && applyEQCompOp(left.lst.listValues[i], value))
      found = 1;
    else{
      newListValues[count] = left.lst.listValues[i];
      count = count + 1;
    }
  }
  assert found;
  left = new MultiType(flag = LIST, lst = new MTList(len = newLen, listValues = newListValues));
}


MultiType getTypeMT(MultiType x){
  if(x.flag == INTEGER) return intTypeMT;
  if(x.flag == LIST) return listTypeMT;
  return intTypeMT;
}

MultiType unknownTypeMT(){
  if(??) return intTypeMT;
  else return listTypeMT;
}


int min(int a, int b){
  if(a>=b) return b;
  else return a;
}
pragma options "--bnd-inbits 2 --bnd-unroll-amnt 4 --bnd-arr-size 4";

MultiType createMTFromInt(int x){
  return new MultiType(val = x, flag=INTEGER);
}

MultiType createMTFromArray(int N, int[N] a){
  MultiType[N] lvalues;
  for(int i=0; i<N;i++)
    lvalues[i] = new MultiType(val=a[i], flag =INTEGER);
  return new MultiType(flag = LIST, lst = new MTList(len=N, listValues=lvalues));
}

int[N] computeArrayFromMT(int N, MultiType a){
  int[N] result = 0;
  assert a.flag == LIST;
  for(int i=0; i<a.lst.len; i++){
    assert a.lst.listValues[i].flag == INTEGER;
    result[i] = a.lst.listValues[i].val;
  }
  return result;
}

int[N] compute_deriv_teacher_driver(int N, int[N] poly){
  int[N] result = 0;
  if(N==0) return result;
  MultiType polyMT = createMTFromArray(N, poly);
  MultiType result1 = compute_deriv_teacher(polyMT);
  assert result1.flag == LIST;
  if(N==1) assert result1.lst.len == 1;
  else assert result1.lst.len == N-1;
  result = computeArrayFromMT(N, result1);
  return result;
}

int[N] compute_deriv_student_driver(int N, int[N] poly) implements compute_deriv_teacher_driver{
  int[N] result = 0;
  if(N==0) return result;
  MultiType polyMT = createMTFromArray(N, poly);
  MultiType result1 = compute_deriv(polyMT);
  assert result1.flag == LIST;
  if(N==1) assert result1.lst.len == 1;
  else assert result1.lst.len == N-1;
  result = computeArrayFromMT(N, result1);
  calculateChanges();
  return result;
}

