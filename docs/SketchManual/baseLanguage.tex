\section{Core language}
The core sketch language is a simple imperative language that borrows most of its syntax from Java and C. 

\subsection{Primitive Types}
The sketch language contains only two primitive types, \C{int} and \C{bit}. The \C{bit} type is actually a subtype of \C{int}, so bit variables can be used wherever an integer is required. There are only two bit constants, \C{0}, and \C{1}. Bits are also used to represent Booleans; the bit-value \C{0} corresponds to \C{false}, and \C{1} corresponds to \C{true}. 
\subsection{Arrays}
The \Sk\ language supports fixed size arrays of any supported type. The syntax for the type constructor is as follows; if we want to declare a variable \C{a} to be an array of size \C{N} with elements of type \C{T}, we can declare it as:
\begin{lstlisting}
      T[N] a;
\end{lstlisting}

The syntax for array access is similar to that in other languages; namely, the expression \C{a[x]} produces an element of type \C{T} when the type of \C{a} is \C{T[N]}, provided that \C{x<N}. All array accesses are automatically checked for array bounds violations.

The constructor above works for any type \C{T}  including other array types. This makes the semantics very simple, although it can be a little confusing for people who are used to working in languages with support for multi-dimensional arrays. To illustrate this point, consider the following example:
\begin{Example}
Consider the declaration below.
\begin{lstlisting}
int[N][M] a;
\end{lstlisting}
The type of \C{a} is \C{int[N][M]}. This means that for an \C{x < M}, \C{a[x] } is of type \C{int[N]}, and for any \C{y < N}, \C{a[x][y]} is of type \C{int}.   
\end{Example}

\paragraph{Bulk array access}
The indexing operation we just saw will read a single element from an array. The \SK\ language also contains support for extracting sub-arrays out of an array. If \C{a} is an array of type \C{T[N]}, we can extract a sub-array of size \C{M} using the following expression. 
\begin{lstlisting}
a[x::M]
\end{lstlisting}

If \C{M} is a constant greater than zero and \C{x + M $~\leq~$ N}, then the expression \C{ a[x::M]} produces an array of type \C{T[M]} containing the elements \C{a[x], ..., a[x+M-1]}. The expression \C{M} should be final, i.e. it cannot include any expressions with side effects (array accesses, function calls or unary increments) and any variables within it should be assigned only once and never changed (just like finals in Java; see more info in \secref{dlenarrs}).
Bulk array access of the form \C{a[x::M]} will generate an exception if any index between \C{x} and \C{x+M-1} is out of bounds. Specifically, the system checks that \C{x>=0} and \C{x+M <= N}, where \C{N} is the size of \C{a}. Notice that if \C{M} is zero, then it is legal for \C{x} to equal \C{N}.

\paragraph{Array assignment}
The language also supports bulk copy from one array to another through array assignment operator. If \C{a} and \C{b} are arrays of type \C{T[N]}, then the elements of  \C{a} can be copied into \C{b} by using the assignment operator: 
\begin{lstlisting}
   b = a;
\end{lstlisting}
If \C{a:T[N]} and \C{b:T[M]} are of different size, then the assignment will be legal as long as \C{M $\geq$ N}. If \C{M $\neq$ N}, the rhs will be padded with zeros or nulls according to the rules in \secref{padding}.

Bulk array access operations can also serve as lvalues. For example, the assignment 
\begin{lstlisting}
b[2::4] = a[5::4] 
\end{lstlisting}
is legal---assuming of course that a and b are big enough for the bulk accesses to be legal. The effect of this operation is to write values a[5], a[6], a[7], a[8] into locations b[2], b[3], b[4], b[5]. For such an assignment, the compiler will read all the values in the right hand side before writing anything to the left hand side. This is relevant when reading and writing to the same array. For example, the assignment 
\begin{lstlisting}
a[0::3] = a[1::3] 
\end{lstlisting}
will read values  \C{a[1], a[2], a[3]} before writing to locations  \C{a[0], a[1], a[2]}.

\paragraph{Array constants}
\seclabel{ainit}
Sketch supports C-style array constants. An array constant of k-elements is expressed with the following syntax.
\begin{lstlisting}
{ a1, a2, ... , ak}
\end{lstlisting}
Array constants in \Sk{} are more flexible than in C. They are not restricted to array initialization; they can be used anywhere an array rvalue can be used. In particular, the following are all valid statements in sketch:
\begin{lstlisting}
int[3] x = {1,2,3};
x[{1,2}[a]] = 3;
x[0] = {4,5,6}[b];
x[{0,1}[a]::2] = {0,1,2,3,4,5,6}[b::2];
\end{lstlisting}

\paragraph{Nested array constants}
The entries \C{a1} through \C{ak} in the array initializer can themselves be arrays, which makes it possible for the system to support nested array initializers. The type for an array initializer will be defined by the following rule:
\[
	\frac{\tau = \bigsqcup \tau_i~~~ \Gamma\vdash a_i:\tau_i }{\Gamma \vdash \{a_0, a_1, \ldots a_{k-1}\}:\tau[k]}
\]
Given two array types $\tau_1[N]$ and $\tau_2[M]$, the type $\tau_1[N] \sqcup \tau_2[M]$ is equal to $(\tau_1 \sqcup \tau_2)[max(N,M)]$. The system pads the nested array initializers according to the rules in \secref{padding}. For example, an array of the form
\begin{lstlisting}
{{1,2},{1},{1,2,3},{1}}
\end{lstlisting}
will be of type int[3][4], and will be equivalent to the following array:
\begin{lstlisting}
{{1,2,0},{1,0,0},{1,2,3},{1,0,0}}
\end{lstlisting}


\paragraph{Array Equality.} The equality comparison recursively compares each element of the array and works for arrays of arbitrary types. In addition to comparing each element of the array, the equality comparison also compares the sizes of the array, so arrays of different sizes will be judged as being different even if after padding they would have been the same.
In general, two arrays \C{a:T[n]} and \C{b:T[m]} will be compared according to the following recursive definition:

\begin{lstlisting}
	a:T[n] == b:T[m]  $\Rightarrow$ n==m $\wedge \forall$ i < n a[i]==b[i]
	a:T[n] == b:$\tau$      $\Rightarrow$ n==1 $\wedge$ a[0] == b
\end{lstlisting}
In the second line, it is assumed that $\tau$ is a non-array type. There is a symmetric case when \C{a} is of a non-array type.


\begin{Example}
Given two arrays, \C{int[n][m] y} and \C{int[m][n] z}, the following assertion will always succeed:
\begin{lstlisting}
if(x==y){
	assert n==m;
}
\end{lstlisting}
That is because the only way \C{x} and \C{y} can be equal is if their dimensions are equal. Similarly, given two arrays \C{int[p][n][m] a} and \C{int[t] b}, the assertion below will always succeed:
\begin{lstlisting}
if(a==b){
	assert t==m && n==1 && p == 1;
}
\end{lstlisting}
\end{Example}


\paragraph{Bit Vectors}
While a sketch programmer can create arrays of any arbitrary type, arrays of bits allow an extended set of operations to allow programmers to easily write bit-vector algorithms. The set of allowed operators is listed below, and the semantics of each operator is the same as the equivalent operator for unsigned integers in C.
\begin{center}
\begin{tabular}{r}
\lstinline!bit[N] & bit[M] $\rightarrow$ bit[max(N,M)]!\\
\lstinline!bit[N] | bit[M]  $\rightarrow$ bit[max(N,M)]!\\
\lstinline!bit[N] ^ bit[M]  $\rightarrow$ bit[max(N,M)]!\\
\lstinline!bit[N] + bit[M]  $\rightarrow$ bit[max(N,M)]!\\
\lstinline!bit[N] >> int    $\rightarrow$ bit[N]!\\
\lstinline!bit[N] << int    $\rightarrow$ bit[N]!\\
!\lstinline!bit[N] $\rightarrow$ bit[N]!\\
\end{tabular}
\end{center}

Notice that most operators support operands of different sizes; the smaller array is padded to match the size of the bigger array according to the rules of padding from \secref{padding}. 


\subsection{Dynamic Length Arrays}\seclabel{dlenarrs}
When you declare an array of type \C{T[N]}, it is possible for \C{N} to be an arbitrary expression. For example, consider the following code:
\begin{lstlisting}
harness void main(int n, int[n] in){
 int[n] out = addone(n, in);
}
int[n] addone(int n, int[n] in){
  int[n] out;
  for(int i=0; i<n; ++i){
    out[i] = in[i]+1;
  }
  return out;
}
\end{lstlisting}
The code above illustrates one of the most common uses of dynamic length arrays: allowing functions to take arrays of arbitrary size. There are a few points worth mentioning. First, note that the size in the return array of \C{addone} refers to one of the parameters of the function. In general, the output type can refer to any of the input parameters, as well as to any \emph{constant} global variables---\ie{} global variables that are assigned a constant value upon declaration and are never changed again. Similarly, the type of an input parameter can refer to any variable that comes before it. However, output types and types of input parameters can not involve any function calls. 

If a variable is used in the size of an array, its value should be final; \ie{} the value of that variable should not change during its scope. This rules out the use of reference parameters in array length expressions. It also means that some care must be taken if the length of the array is to be computed by the function. 

\begin{Example}
Consider a function that filters an array to return only those elements that are even. One cannot know the length of the return array a priori, because it depends on the data in the original array. One way to write such a function is as follows:
\begin{lstlisting}
int[N] filter(int N, int[N] in, ref int outsz){
	outsz = 0;
	int[N] out;
	for(int i=0; i<N; ++i){ 
		if(in[i]%2 == 0){
			out[outsz++] = in[i];			
		}
	}
	return out;
}
\end{lstlisting}
Notice that the function returns an array of size N, even though in reality, only the first \C{outsz} elements matter. We may use the function as follows:
\begin{lstlisting}
int[N] tmp = filter(N, in, tsz);
int sz = tsz;
int[sz] filteredArray = tmp[0::sz];
\end{lstlisting}
This is admittedly awkward, and we hope to have better idioms for this in future versions of the language, but for know, that is the simplest way of producing an array of unknown length.
\end{Example}


\flagdoc{bnd-arr-size}{
If an input array is dynamically sized, the flag \C{--bnd-arr-size} can be used to control the maximum size arrays to be considered by the system. For any non-constant variable in the array size, the system will assume that that variable can have a maximum value of \C{--bnd-arr-size}. For example, if a sketch takes as input an array \C{int[N] x}, if \C{N} is another parameter, the system will consider arrays up to size \C{bnd-arr-size}. On the other hand, for an array parameter of type \C{int[N*N] x}, the system will consider arrays up to size \C{bnd-arr-size}$^2$.
}



\subsection{Structs}
In addition to arrays, the \Sk{} language supports heap allocated records. 

To define a new record type, the programmer uses the following syntax (borrowed from C):
\begin{lstlisting}
struct $name${
  $type_1$ $field_1$;
  ...
  $type_k$ $field_k$;
}
\end{lstlisting}
One restriction on the types of fields is that you cannot have dynamic sized arrays; all array sizes must be compile time constants.


To allocate a new record in the heap, the programmer uses the keyword \C{new}; the syntax is the same as that for constructing an object in Java using the default constructor. 

Records are manipulated through references, which behave the same way as references in Java. The following example illustrates the main properties of records and references in \Sk{}.

\begin{Example}
The example below will behave the same way as an equivalent example would behave in Java. In particular, all the asserts will be satisfied.
\begin{lstlisting}
struct Car{
  int license;
}

void main(){
  Car c = new Car();
  Car d = c;
  c.license = 123;
  assert d.license == 123;
  strange(c, d);
  assert d.license == 123;
  assert d == c;
}

void strange(Car x, Car y){
  x = new Car();
  y = new Car();
  x.license = 456;
  y.license = 456;
  assert x.license == y.license;
  assert x != y;
}
\end{lstlisting}

\end{Example}

Just like in Java, references are typesafe and the heap is assumed to be garbage collected (which is another way of saying the synthesizer doesn't model deallocation). A consequence of this is that a reference to a record of type T must either be \C{null} or point to a valid object of type T. Also, just like in Java, all pointer dereferences have an implicit null pointer check.


\subsection{Automatic Padding and Typecasting}
\seclabel{padding}
Many operations on arrays support arrays of different sizes through padding. This padding can be thought of as an implicit typecast from small arrays to bigger arrays. The objects used to pad the array depend on the type of the array. Given an array of type \C{T[N]}, the objects used to pad the array will be defined by the function \lstinline!$pad$(T)! defined by the following rules:
\begin{lstlisting}
$pad$(int) = 0 
$pad$(bit) = 0
$pad$(struct) = null
$pad$(T[N]) = $\{pad$(T)$,\ldots, pad$(T)$\}$ //N copies of $pad$(T)
\end{lstlisting}

\begin{Example}
In the statement \lstinline!int[4] x = {1,2};!, the right hand side has size 2, but will be implicitly cast to an array of size 4 by padding it with the value \lstinline!$pad$(int)=0!, so after the assignment, \C{x} will equal \lstinline!{1,2,0,0}!.
\end{Example}


A second form of implicit typecasting happens when a scalar is used in place of an array. In this case, the scalar is automatically typecast into an array of size 1. 

\begin{Example}
Consider the following block of code 
\begin{lstlisting}
struct Car{ ... }
...
Car[4] x;
Car t = new Car();
x = t;
\end{lstlisting}
This code actually involves two typecasts. First, \C{t} will be typecast from the scalar type \C{Car} to the array type \C{Car[1]}. Then, the array type \C{Car[1]} will be typecast to a bigger array of type \C{Car[4]} by padding with \lstinline!$pad$(Car) = null!. The result is that array will be equal to \lstinline!{t, null, null, null}!.
\end{Example}

\begin{Example}
Padding also works for assignments involving nested arrays.
\begin{lstlisting}
int[2][2] x = {{2,2}, {2,2}};
int [4][4] y = x;
\end{lstlisting}

The code above involves the following implicit typecasts: first, the array x of type \C{int[2][2]} is typecast into an array of type \C{int[2][4]} by padding with \lstinline!$pad$(int[2])={ $pad$(int), $pad$(int)} = {0, 0}! to produce the array \lstinline!{{2,2}, {2,2}, {0,0}, {0,0}}!. Then, each entry in this array is typecast from \C{int[2]} to \C{int[4]}, so after the assignment, the value of \C{y} will be equal to \lstinline!{{2,2,0,0}, {2,2,0,0}, {0,0,0,0}, {0,0,0,0}}!
\end{Example}


It is important to note that implicit casts only occur for r-values; l-values will never be implicitly typecast. In particular, this means that reference parameters to a function will never be implicitly cast and must always be of the exact size required by the signature of the callee. 


\subsection{Explicit Typecasting}
The \Sk{} language also offers some limited explicit typecasting. In particular, the language offers only two explicit typecasts:
\begin{itemize}

\item An array \C{a} of type \C{T[N]} can be explicitly typecast into an array of type \C{T[M]} by using the syntax \C{(T[M])a} (standard typecast notation from C). When an array is typecast to a smaller size, the remaining elements are simply truncated. 

\item A bit array \C{bit[N]} can be explicitly typecast into an integer. When this happens, the first bit in the array is interpreted as the least significant bit and the last one as the most significant bit. The reverse cast from an integer to a bit array is not supported.

\end{itemize}

\begin{Example}
One instance where explicit casting is useful is when comparing an array against the zero array.
\begin{lstlisting}
int[N] x=...;
assert x == (bit[N])0;
\end{lstlisting}
Notice that in the code above, if we had written simply \C{x==0} in the assertion, the assertion would have been violated when \C{N>1}, because the scalar zero is treated as an array of size 1. By casting the constant zero into an array of size \C{N}, we ensure that x is compared against an array of size \C{N} consisting of all zeros.
\end{Example}

\begin{Example}
Explicit casting is also useful when copying one dynamically sized array into another one.
\begin{lstlisting}
int[N] x=...;
int[M] y = (bit[M])x;
\end{lstlisting}
If we knew that \C{N} is smaller than \C{M}, we could have written simply \C{y=x}, and the automatic padding would have made the assignment correct. Similarly, if we knew that \C{M} is smaller than or equal to \C{N}, assigning \C{y=x[0::M]} would have been legal. However, \C{y=x} fails when \C{M} is smaller than \C{N}, and x[0::M] fails when \C{M>N}. The cast on the other hand succeeds in both cases and has the expected behavior.
\end{Example}

\subsection{Control Flow}
The language supports the following constructs for control flow: \C{if-then}, \C{while}, \C{do-while}, \C{for}. These have the same syntax and semantics as in \C{C/C++} or \C{Java}. The language does not have a \C{switch} statement, although it is likely to be added in a future version of the language. The language also does not support \C{continue} and \C{break}, although they can easily be emulated with \C{return} by using closures (see \secref{closures}).

The synthesizer reasons about loops by unrolling them. The degree of unrolling is controlled by a flag \C{--bnd-unroll-amnt}. If the loop iteration bounds are static, however, the loop will be unrolled as many times as necessary to satisfy the static bounds. 

\flagdoc{bnd-unroll-amnt}{This flag controls the degree of unrolling for both loops and \C{repeat} constructs}


\begin{Example}
Consider the three loops below.
\begin{lstlisting}
for(int i=0; i<N; ++i){...}
for(int i=0; i<100; ++i){...}
for(int i=0; i<N && i<7; ++i){...}
\end{lstlisting}
If \C{N} is an input variable, the first loop will be unrolled as many times as specified by \C{--bnd-unroll-amnt}. The second loop will be unrolled \C{100} times regardless of the value of the flag. For the third loop, the unroll factor will be controlled by the flag, but will never exceed seven.
\end{Example}




\subsection{Global variables}
The sketch language supports global variables with one important restriction: global arrays must be of constant dimension. You can use global variables for the dimension of an array as long as the global variable is constant. Global variables that are passed as reference parameters, or that are passed as parameters to function parameters will be considered to be non-constant. 


\subsection{Functions}
The sketch language also supports functions. The syntax for declaring a function is the same as in C. 

\begin{lstlisting}
$ret\_type$ $name$($args$){
  $body$
}
\end{lstlisting}

\paragraph{Recursion}
The synthesizer reasons about function calls by inlining them into their calling context. In principle, this could be problematic for recursive functions, but in practice this usually is not a problem. The synthesizer uses a flag \C{bnd-inline-amnt} to bound the maximum number of times a function can be inlined. If any input requires inlining more than the allowed number of times, synthesis will fail.

\flagdoc{bnd-inline-amnt}{Bounds the amount of inlining for any function call. The value of this parameter corresponds to the maximum number of times any function can appear in the stack.}


\paragraph{Reference Vs. Value Parameter Passing}
By default, parameter passing is done by value; however, it is possible to pass parameters by reference by prefixing them with the keyword \C{ref}. 

Only local variables should ever be passed by reference, and reference parameters should never be aliased. The reason for this restriction is that the synthesizer models reference parameters using copy-in-copy-out semantics. If the parameters are local variables and are not aliased, then copy-in-copy-out is indistinguishable from pass-by-reference.

\subsection{Function parameters}
Functions can also take functions as parameters. We use the keyword \C{fun} to denote a function type. The example below illustrates the use of function parameters.
\begin{lstlisting}
int apply(fun f, int x){
	return f(x);
}
int timesTwo(int x){
	return x+x;
}

harness void main(int x){
	assert apply(timesTwo, x) == 2*x;
}
\end{lstlisting}

The language imposes several restrictions on the use of the \C{fun} type. First, the type can only be used for parameters. You cannot declare a variable or a data-structure field of type \C{fun}. There are also no operators defined for functions; in particular, the ternary operator \C{?:} cannot be used with functions. You can also not create arrays of functions, and you cannot use functions as return values or reference parameters to a function. In short, functions are not quite first class citizens in sketch, but function parameters do enable some very useful idioms.

\subsection{Local functions and closures}\seclabel{closures}
Sketch supports the definition of functions inside other functions. The syntax for doing this is the same as when the function is defined outside a function. The body of the locally defined function can access any variable that is in scope in the context of the function definition. The example below illustrates how local functions can be used together with high-order functions. 

\begin{lstlisting}
void ForLoop(fun f, int i, int N){
	if(i<N){
		f(i);
		ForLoop(f, i+1, N);
	}
}

harness void main(int N, int[N] A){
	int[N] B;
	void copy(int i){
		B[i] = A[i];
	}
	ForLoop(copy, 0, N);
	assert A == B;
}
\end{lstlisting}
	
In the sketch above, \C{ForLoop} takes the closure involving the function \C{copy} and its local environment; the effect of the call to \C{ForLoop} is the same as if the body of copy had been placed in a traditional \C{for} loop. 

\subsection{Packages}

The \Sk{} language supports packages. A package is identified by the \C{package} statement at the beginning of a file.
\begin{lstlisting}
package PACKAGENAME;
\end{lstlisting}

All the functions and structures defined in a file must belong to the same package, so the compiler will produce an error if there is more than one package definition in a file. If a file does not have a \C{package} command, then by default its contents will belong to the package \C{ANONIMOUS}. Also, note that unlike Java, package names cannot have periods or other special symbols. 

A file can import other packages by using the \C{include} command. The syntax of the command is shown below. The string in quotes corresponds to the name of the file where the package resides. 

\begin{lstlisting}
include "file.sk";
\end{lstlisting}

The include command should not be confused with the \C{#include} preprocessor directive, which simply inlines the contents of a file and is not really part of the language. 

\flagdoc{fe-inc}{
The command line flag {--fe-inc} can be used to tell the compiler what directories to search when looking for included packages. The flag works much like the \C{-I} flag in gcc, and can be used multiple times to list several different directories.
}

Each package defines its own namespace, allowing the system to avoid name conflicts. Code in one package can explicitly refer to functions or structures defined in another package by using the \C{@} notation. For example, a call of the form \C{foo@pk()} will call a function \C{foo} defined in package \C{pk}. Similarly, a declaration of the form \C{Car@vehicles c = new Car@vehicles()} defines a new object of type \C{Car}, where the type was defined in the package \C{vehicles}. In the absence of an explicit package name, the system will search for definitions of functions and structures as follows:
\begin{itemize}
\item If the name is defined locally in the same package, the local definition will be used.
\item If the name is not defined locally in the same package, but is only defined in one other package (so there is no ambiguity), then the definition in that other package will be used.
\item If the name is not defined locally in the same package and the same name is defined in multiple packages, then you need to explicitly name the package or you will get a compiler error.
\end{itemize}
\begin{Example} The example below illustrates the use of packages.\newline
\begin{tabular}{cp{2cm}c}
\begin{lstlisting}
// Begin file farm.sk
package farm;
struct Goat{
   int weight;  }
struct Ram{
   int age;     }
struct Mouse{
   int age;     }
// End file farm.sk
\end{lstlisting} & ~ &
\begin{lstlisting}
// Begin file computer.sk
package computer;
struct Cpu{
   int freq;    }
struct Ram{
   int size;    }
struct Mouse{
   bit isWireless; }
// End file computer.sk
\end{lstlisting}
\end{tabular}
\begin{lstlisting}
//Begin file test.sk
include "computer.sk";
include "farm.sk"
struct Mouse{
   int t;  
}
harness main(){
   Cpu c = new Cpu(); // No ambiguity here.
   Ram@farm r = new Ram@farm() //Without @farm, this would be an error.
   Ram@computer rc = new Ram@computer();
   Mouse m = new Mouse(); // Give preference to the locally defined mouse.
   m.t = 10;
}
//End file test.sk
\end{lstlisting}
\end{Example}
