#define SPMD_MAX_BUF_LEN 64
#include "spmd.h"

#define N_INT 16
// number of internal points in each direction
#define P 4
// Processors in each direction

float sten(float left, float right, float top, float bottom);

void pass_red(int N, ref float [N][N] u)
{
    int i, j;
    for(i=1; i<N-1; i++)
	for(j=1+(i-1)%2; j<N-1; j=j+2)
	    u[i][j] = sten(u[i][j-1], u[i][j+1], u[i-1][j], u[i+1][j]);
}


void pass_black(int N, ref float[N][N] u)
{
    int i, j;
    for(i=1; i<N-1; i++)
	for(j=1+i%2; j<N-1; j=j+2)
	    u[i][j] = sten(u[i][j-1], u[i][j+1], u[i-1][j], u[i+1][j]);
}

void pass(ref float[N_INT+2][N_INT+2] gu)
{
    pass_red(N_INT+2, gu);
    pass_black(N_INT+2, gu);
}

void spmdpass(ref float [N_INT+2][N_INT+2] gu) implements pass
{
    int n = N_INT / P;
    int N = n+2;

    spmdinfo info = spmdinit(P*P, n);

    spmdfork(rank; P*P) {
        int px;
        int py;
        px = rank % P;
        py = rank / P;

        int i;
        int j;

        int left;
        int right;
        int top;
        int bottom;

        left = (rank % P == 0) ? -1 : rank - 1;
        right = ((rank+1) % P == 0) ? -1 : rank + 1;
        top = (rank < P) ? -1 : rank - P;
        bottom = (rank >= P*(P-1)) ? -1 : rank + P;

        float [N][N] u;
        float [n] buff_send;
        float [n] buff_recv;

        // move in
        for (i=0; i<N; ++i) {
            for (j=0; j<N; ++j) {
                u[i][j] = gu[n*py + i][n*px + j];
            }
        }

        if (n%2==0 || (px+py)%2==0) {
            pass_red(N, u);
        } else {
            pass_black(N, u);
        }

        // communicate
        spmdtransfer(info, n, u[1][1::n], (top>=0), top, u[N-1][1::n], (bottom>=0));
        if (left>=0) {
            for (i=0; i<n; ++i) {
                buff_send[i] = u[i+1][1];
            }
        }
        spmdtransfer(info, n, buff_send, (left>=0), left, buff_recv, (right>=0));
        if (right>=0) {
            for (i=0; i<n; ++i) {
                u[i+1][N-1] = buff_recv[i];
            }
        }

        spmdtransfer(info, n, u[n][1::n], (bottom>=0), bottom, u[0][1::n], (top>=0));

        if (right>=0) {
            for (i=0; i<n; ++i) {
                buff_send[i] = u[i+1][n];
            }
        }
        spmdtransfer(info, n, buff_send, (right>=0), right, buff_recv, (left>=0));
        if (left>=0) {
            for (i=0; i<n; ++i) {
                u[i+1][0] = buff_recv[i];
            }
        }

        if (n%2==0 || (px+py)%2==0) {
            pass_black(N, u);
        } else {
            pass_red(N, u);
        }

        // move out
        for (i=1; i<N-1; ++i) {
            for (j=1; j<N-1; ++j) {
                gu[n*py + i][n*px + j] = u[i][j];
            }
        }
    }
}
