pragma options "-p preproc --bnd-inbits 3 --bnd-cbits 2 --bnd-unroll-amnt 9 --bnd-inline-amnt 2 --beopt:-bndwrand 50  --bnd-arr-size 16 --be:ufunSymmetry  --beopt:simplifycex NOSIM --beopt:simiters 10"; //  --be:showDAG

void specCenter(int n, int T, ref float[n+T+T%2][T] A){    
    if ( (n>(T-1)*2) && (T>1 && T<4) ){
        for(int t=1; t<T; ++t){
            for(int i=(T+1)/2+t; i<(T+1)/2+n-t; ++i){
                A[t][i] = A[t-1][i-1] + A[t-1][i+1];
            }   
        }
    }
}

generator int pos_neg() {
	if (??(1)) {
		return 1;
	} else {
		return -1;
	}
}

generator int signed() {
	return ??*pos_neg();
}

generator int legen3(int x, int y, int z) {
	return ??*x + ??*y + ??*z + signed();
}

generator int legen4(int x, int y, int z, int w) {
	return ??*x + ??*y + ??*z + ??*w + signed();
}

void fastCenter(int n, int T, ref float[n+T+T%2][T] A) {
	generator void sten(int t, int i) {
		A[t][i] = A[t-1][i-1]+A[t-1][i+1];
	}
	if (	(n>(T-1)*2) && (T>1 && T<4) ){
		repeat(2){
			for (int s=legen3(n, T, T%2); s<legen3(n, T, T%2); ++s) {
				for (int t=legen4(n, T, T%2, s); t<legen4(n, T, T%2, s); ++t) {
					repeat(??) {
						sten(t+??, s-t+??);
					}
				}
			}
		}
	/*	for (int j=1; j<T-1; ++j) {
			for (int t=1; t<=j; ++t) {
				int i = (T+1)/2 + j*2-t + pos_neg_zero();  // 0
				A[t][i] = A[t-1][i-1] + A[t-1][i+1];
				A[t][i+1] = A[t-1][i] + A[t-1][i+2];
			}
		}
	    for(int j=2*(T-2)+1; j<n-1; ++j){
	        for(int t=1; t<T; ++t){
	            int i = (T+1)/2 + j-t + pos_neg_zero();  // 1
                A[t][i] = A[t-1][i-1] + A[t-1][i+1];
	        }           
	    }*/
	}
}


stencil float[n+T+T%2][T] specCenterSten(int n, int T, float[n+T+T%2][T] in) {    
	float[n+T+T%2][T] out = in;
	specCenter(n, T, out);
	return out;
}

stencil float[n+T+T%2][T] fastCenterSten(int n, int T, float[n+T+T%2][T] in) implements specCenterSten {    
	float[n+T+T%2][T] out = in;
	fastCenter(n, T, out);
	return out;
}
