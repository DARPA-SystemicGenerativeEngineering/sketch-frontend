#define N_INT 3
// number of internal points in each direction
#define P 3
// Processors in each direction

#define n (N_INT/P)
#define N (n+2)

#define SPMD_MAX_BUF_LEN (P*P*n)
#include "spmd.h"

include "generators.skh";

float sten(float left, float right, float top, float bottom);

float rb_spec(int i, int j, int t)
{
    if (i == 0 || j == 0 || i == N_INT+1 || j == N_INT+1 || t == 0) {
        return 0;
    } else if ((i+j+t)%2 == 0) {
        return rb_spec(i, j, t-1);
    } else {
        return sten( rb_spec(i, j-1, t-1), rb_spec(i, j+1, t-1), rb_spec(i-1, j, t-1), rb_spec(i+1, j, t-1) );
    }
}

void pass(ref float [N_INT+2][N_INT+2] u, bit red)
{
    for(int i=1; i<=N_INT; ++i)
	for(int j=1+(i+red)%2; j<=N_INT; j+=2)
	    u[i][j] = sten(u[i][j-1], u[i][j+1], u[i-1][j], u[i+1][j]);
}

void passN(ref float [N][N] u, bit red)
{
    for(int i=1; i<N-1; ++i)
	for(int j=1+(i+red)%2; j<N-1; j+=2)
	    u[i][j] = sten(u[i][j-1], u[i][j+1], u[i-1][j], u[i+1][j]);
}

void rb_seq(int T)
{
    float[N_INT+2][N_INT+2] u;
    
    for (int t=1; t<=T; ++t) {
        pass(u, (t%2 == 1));
    }
    for (int i=1; i<=N_INT; ++i) {
        for (int j=0; j<=N_INT; ++j) {
            assert u[i][j] == rb_spec(i, j, T);
        }
    } 
}

harness void check()
{
    for (int T=0; T<2; ++T) {
        rb_spmd(T);
    }
}

void communicate(global spmdinfo info, ref float[N][N] u, int rank)
{
    float [n] buff_send;
    float [n] buff_recv;
    int p = rank / P;
    int q = rank % P;
    int left = (q == 0) ? -1 : rank - 1;
    int right = (q == P-1) ? -1 : rank + 1;
    int top = (p == 0) ? -1 : rank - P;
    int bottom = (p == P-1) ? -1 : rank + P;

    spmdtransfer(info, n, u[1][1::n], (top>=0), top, u[N-1][1::n], (bottom>=0));
    
    if (left>=0) {
        for (int i=0; i<n; ++i) {
            buff_send[i] = u[i+1][1];
        }
    }
    spmdtransfer(info, n, buff_send, (left>=0), left, buff_recv, (right>=0));
    if (right>=0) {
        for (int i=0; i<n; ++i) {
            u[i+1][N-1] = buff_recv[i];
        }
    }

    spmdtransfer(info, n, u[n][1::n], (bottom>=0), bottom, u[0][1::n], (top>=0));

    if (right>=0) {
        for (int i=0; i<n; ++i) {
            buff_send[i] = u[i+1][n];
        }
    }
    spmdtransfer(info, n, buff_send, (right>=0), right, buff_recv, (left>=0));
    if (left>=0) {
        for (int i=0; i<n; ++i) {
            u[i+1][0] = buff_recv[i];
        }
    }
}

void rb_spmd(int halfT)
{
    int T = halfT*2;
    spmdinfo info = spmdinit(P*P, n);    
    spmdfork(rank; P*P) {
        float [N][N] u;

        int p = rank / P;
        int q = rank % P;

        //bit iamred = n%2==0 || (p+q)%2==0;
        bit iamred = n%2==0 || expr(3, {p, q, 2}, 2, {MOD, PLUS}) == 0; //(p+q)%2 == 0;

        int t=1;
        while (t<=halfT) {
            communicate(info, u, rank);
            passN(u, iamred);
            communicate(info, u, rank);
            passN(u, !iamred);
            ++t;
        }

        for (int i=1; i<=n; ++i) {
            for (int j=1; j<=n; ++j) {
                int gi = p*n + i;
                int gj = q*n + j;
                assert u[i][j] == rb_spec(gi, gj, T);
            }
        }
    }
}

