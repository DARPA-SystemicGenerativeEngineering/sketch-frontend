pragma options "--bnd-inbits 2 --bnd-cbits 3 --bnd-unroll-amnt 16 --bnd-inline-amnt 10 --beopt:-bndwrand 50  --bnd-arr-size 16 --be:ufunSymmetry  --beopt:simplifycex NOSIM"; //  --be:showDAG

//#define SPMD_MAX_BUF_LEN 16
//include "spmd2.skh"

void move_in(global int N, global int T, global float[N][T] ga, global int n, ref float[n][T] la) {
	for (int t=0; t<T; ++t) {
		for (int i=0; i<n; ++i) {
			la[t][i] = ga[t][spmdpid*n + i];
		}
	}
}

void move_out(global int N, global int T, ref global float[N][T] ga, global int n, float[n][T] la) {
	for (int t=0; t<T; ++t) {
		for (int i=0; i<n; ++i) {
			ga[t][spmdpid*n + i] = la[t][i];
		}
	}
}

/*
stencil float[N][T] specCenter(int np, int N, int T, float[N][T] in) {
    float[N][T] out;
    if(N>=4 && T >= 3 && N>T*2){
        out[0] = in[0];
        for(int t=1; t<T; ++t){
            for(int i=t; i<N-t; ++i){
                out[t][i] = out[t-1][i-1] + out[t-1][i+1];
            }
        }
    }
    return out; 
}
*/

float[N][T] specInit(int np, int N, int T) {
	float[N][T] out = 0.0;
    if( (np>0 && np<=4) && (N%np==0) && (T>1 && T<4) ){
		for (int i=0; i<N; ++i) {
			out[0][i] = 1.0;
		}
    }
	return out;
}

float[N][T] fastInit(int np, int N, int T) implements specInit {
	float[N][T] out = 0.0;
    if( (np>0 && np<=4) && (N%np==0) && (T>1 && T<4) ){
	    	global int n = N/np;
		spmdfork(np) {
			float[n][T] A = 0.0;
			for (int i=0; i<n; ++i) {
				A[0][i] = 1.0;
			}
			move_out(N, T, out, n, A);
		}
    }
	return out;
}


/*
float[N][T] fastCompute(int N, int T, float[N][T] in) implements spec {
	float[N][T] out = in;
	global int n = N/np;
	spmd_fork() {
		float[n][T] A;
		move_in(N, T, out, n, A));
		
		move_out(N, T, out, n, A);
	}
}
*/


/*
stencil float[N][T] specNext(int np, int N, int T, float[N][T] in) {
    float[N][T] out = in;
    if( (np>0 && np<=4) && (N%np==0) && (T>1 && T<4) ){
        out[0] = out[T-1];
    }
    return out; 
}

stencil float[N][T] fastNext(int np, int N, int T, float[N][T] in) implements specNext {
	float[N][T] out = in;
    if( (np>0 && np<=4) && (N%np==0) && (T>1 && T<4) ){
		global int n = N/np;
    		spmdfork(np) {
        		float[n][T] A;
    			move_in(N, T, out, n, A);
    			A[0] = A[T+1-??];
    			move_out(N, T, out, n, A);
    		}
    }
    return out;
}
*/