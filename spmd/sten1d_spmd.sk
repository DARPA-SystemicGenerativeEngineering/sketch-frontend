pragma options "--bnd-inbits 2 --bnd-cbits 3 --bnd-unroll-amnt 8 --bnd-inline-amnt 10 --beopt:-bndwrand 50  --bnd-arr-size 16 --be:ufunSymmetry  --beopt:simplifycex NOSIM"; //  --be:showDAG

//#define SPMD_MAX_BUF_LEN 16
//include "spmd2.skh"

void move_in(global int N, global int T, global float[N][T] ga, global int n, ref float[n][T] la) {
	for (int t=0; t<T; ++t) {
		for (int i=0; i<n; ++i) {
			la[t][i] = ga[t][spmdpid*n + i];
		}
	}
}

void move_out(global int N, global int T, ref global float[N][T] ga, global int n, float[n][T] la) {
	for (int t=0; t<T; ++t) {
		for (int i=0; i<n; ++i) {
			ga[t][spmdpid*n + i] = la[t][i];
		}
	}
}



/*
stencil float[N][T] specCompute(int np, int N, int T, float[N][T] in) {
    float[N][T] out;
    if(N>=4 && T >= 3 && N > T*2){
        out[0] = in[0];
        for(int t=1; t<T; ++t){
            for(int i=t; i<N-t; ++i){
                out[t][i] = out[t-1][i-1] + out[t-1][i+1];
            }
        }
    }
    return out; 
}

stencil float[N][T] fastCompute(int N, int T, float[N][T] in) implements spec {
	float[N][T] out;
	spmd_fork() {
		move_in();
		
		move_out();
	}
}
*/

stencil float[N][T] specNext(int np, int N, int T, float[N][T] in) {
    float[N][T] out = in;
    if( (np>0 && np<=4) && (N%np==0) && (T>1 && T<4) ){
        out[0] = out[T-1];
    }
    return out; 
}

stencil float[N][T] fastNext(int np, int N, int T, float[N][T] in) implements specNext {
	float[N][T] out = in;
    if( (np>0 && np<=4) && (N%np==0) && (T>1 && T<4) ){
    		spmdfork(np) {
        		global int n = N/np;
        		float[n][T] la;
    			move_in(N, T, out, n, la);
    			la[0] = la[T+1-??];
    			move_out(N, T, out, n, la);
    		}
    }
    return out;
}