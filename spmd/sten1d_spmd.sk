pragma options "-p preproc --bnd-inbits 3 --bnd-cbits 2 --bnd-unroll-amnt 9 --bnd-inline-amnt 2 --beopt:-bndwrand 50  --bnd-arr-size 16 --be:ufunSymmetry  --beopt:simplifycex NOSIM --beopt:simiters 10"; //  --be:showDAG

#define SPMD_MAX_BUF_LEN 16
#include "spmd2.skh"

#define MAX_LA_LEN 16

int K = 1;

// length of ghost region: (T+1)/2*K
void movein(int rank, global int N, global int T, global float[N][T] ga, global int n, ref float[n+(T+1)/2*K*2][T] la) {
	for (int t=0; t<T; ++t) {
		for (int i=0; i<n; ++i) {
			la[t][i+(T+1)/2*K] = ga[t][rank*n + i];
		}
	}
}

void moveout(int rank, global int N, global int T, ref global float[N][T] ga, global int n, float[n+(T+1)/2*K*2][T] la) {
	for (int t=0; t<T; ++t) {
		for (int i=0; i<n; ++i) {
			ga[t][rank*n + i] = la[t][i+(T+1)/2*K];
		}
	}
}

stencil float[N][T] compute(int np, int N, int T, float[N][T] in) {
	float[N][T] out = in;
    if( (N%np==0) && (T>=3) && ((N/np)>=(T-1)*2*K+1)){
	    	for (int t=1; t<T; ++t) {
			for (int i=0; i<N; ++i) {
				out[t][i] = out[t-1][(i+N-K)%N] + out[t-1][(i+K)%N];
			}
		}
    }
	return out;
}

generator int pos_neg() {
	if (??(1)) {
		return 1;
	} else {
		return -1;
	}
}

generator void fastBoundary(global spmdinfo info, global int np, global int n, global int T, ref float[n+(T+1)/2*K*2][T] A) {
	float[(T-1)*K] send_buf;
	for (int i=0; i<(T-1)*K; ++i) {
		send_buf[i] = A[i/(K*2)][(T+1)/2*K+n*??(1)+(i/(K*2)*K + i%(K*2))*pos_neg()];
	}
	
	float[(T-1)*K] recv_buf;
	int r = (spmdpid== (np-1)*??(1) ) ? (np-1)*??(1) : spmdpid+pos_neg();
	// L: spmdpid==0 ? np-1 : pid+1
	// R: spmdpid==np-1 ? 0 : pid-1
	
	spmdtransfer(info, (T-1)*K, send_buf, 1, r, recv_buf, 1);
	for (int i=0; i<(T-1)*K; ++i) {
		A[i/(K*2)][(T+1)/2*K+n*??(1)+(i/(K*2)*K + i%(K*2))*pos_neg()] = recv_buf[i];
	}
	
	for (int j=0; j<K*(T-1); ++j) {
		int bottom = (j+??)/??+??;
		for (int t=bottom; t<T; ++t) {
			int i = (T+1)/2 + n*??(1) + (j-(t-1)*K)*pos_neg() + ??*pos_neg();
			// L: (T+1)/2 -s+t-1
			// R: n+(T+1)/2+s-t
			A[t][i] = A[t-1][i-K]+A[t-1][i+K];
		}
	}
}

void fastLeft(global spmdinfo info, global int np, global int n, global int T, ref float[n+(T+1)/2*K*2][T] A) {
	fastBoundary(info, np, n, T, A);
}

void fastRight(global spmdinfo info, global int np, global int n, global int T, ref float[n+(T+1)/2*K*2][T] A) {
	fastBoundary(info, np, n, T, A);
}

void trapezoid(int n, int T, int L, ref float[n+L*2][T] A){    
    if ( (T>=3) && (n>=(T-1)*2*K+1) ){
        for(int t=1; t<T; ++t){
            for(int j=t*K; j<n-t*K; ++j){
            		int i = L+j;
                A[t][i] = A[t-1][i-K] + A[t-1][i+K];
            }   
        }
    }
}

//stencil float[n+T+T%2][T] specCenterSten(int n, int T, float[n+T+T%2][T] in) {    
//	float[n+T+T%2][T] out = in;
//	specCenter(n, T, out);
//	return out;
//}
//
//stencil float[n+T+T%2][T] fastCenterSten(int n, int T, float[n+T+T%2][T] in) implements specCenterSten {    
//	float[n+T+T%2][T] out = in;
//	fastCenter(n, T, out);
//	return out;
//}

stencil float[N][T] computeFast(int np, int N, int T, float[N][T] in) implements compute {
	float[N][T] out = in;
    if( (N%np==0) && (T>=3) && ((N/np)>=(T-1)*2*K+1)){
    		global int n = N/np;
    		global spmdinfo info = spmdinit(np, T);
		spmdfork(np) {
			float[n+(T+1)/2*K*2][T] A;
			movein(spmdpid, N, T, out, n, A);
			trapezoid(n, T, (T+1)/2*K, A);
			fastLeft(info, np, n, T, A);
			fastRight(info, np, n, T, A);
			moveout(spmdpid, N, T, out, n, A);
		}
    }
    return out;
}



/*
stencil float[N][T] specNext(int np, int N, int T, float[N][T] in) {
    float[N][T] out = in;
    if( (np>0 && np<=4) && (N%np==0) && (T>1 && T<4) ){
        out[0] = out[T-1];
    }
    return out; 
}

stencil float[N][T] fastNext(int np, int N, int T, float[N][T] in) implements specNext {
	float[N][T] out = in;
    if( (np>0 && np<=4) && (N%np==0) && (T>1 && T<4) ){
		global int n = N/np;
    		spmdfork(np) {
        		float[n][T] A;
    			move_in(N, T, out, n, A);
    			A[0] = A[T+1-??];
    			move_out(N, T, out, n, A);
    		}
    }
    return out;
}
*/